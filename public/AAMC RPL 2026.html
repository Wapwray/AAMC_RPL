<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>AAMC RPL Quiz - V0.1</title>
    <script src="https://cdn.jsdelivr.net/npm/microsoft-cognitiveservices-speech-sdk@1.41.0/distrib/browser/microsoft.cognitiveservices.speech.sdk.bundle-min.js"></script>
    <style>
      :root {
        color-scheme: light;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        --bg: #f4f6f9;
        --card: #ffffff;
        --text: #0f172a;
        --muted: #64748b;
        --border: #e2e8f0;
        --primary: #0b6ea9;
        --primary-dark: #095c8b;
        --camera-width: 260px;
        --camera-height: 180px;
        --camera-select-height: 42px;
        --camera-gap: 10px;
      }
      * { box-sizing: border-box; }
      html, body {
        height: 100%;
        overflow: hidden;
      }
      body {
        margin: 0;
        background: var(--bg) url("/RPL%20Bot%20Artwork/RPL%20Background.jpg") no-repeat center center fixed;
        background-size: cover;
        color: var(--text);
      }
      .page { padding: 24px; height: 100%; overflow: hidden; }
      .shell { max-width: none; width: 100%; margin: 0; display: grid; gap: 18px; }
      .header { display: flex; align-items: center; justify-content: space-between; gap: 12px; }
      .header h1 { margin: 0; font-size: 20px; font-weight: 700; }
      .status { font-size: 13px; color: var(--muted); }
      .progressRow { display: flex; align-items: center; justify-content: space-between; gap: 12px; }
      .progressRow h1 { margin: 0; font-size: 20px; font-weight: 700; }
      .card { width: 100%; background: var(--card); border: 1px solid var(--border); border-radius: 14px; padding: 18px; box-shadow: 0 10px 24px rgba(15, 23, 42, 0.08); }
      .flatCard { background: transparent; border: none; box-shadow: none; padding: 0; }
      .studentContext { display: flex; flex-wrap: wrap; gap: 10px 16px; align-items: baseline; justify-content: space-between; }
      .studentContext__name { font-weight: 700; font-size: 15px; }
      .studentContext__meta { font-size: 13px; color: var(--muted); }
      .micSelectRow { margin-top: 12px; display: grid; gap: 6px; }
      .micSelectHint { font-size: 12px; color: var(--muted); }
      /* .modeToggleRow { display: flex; align-items: center; justify-content: space-between; gap: 12px; }
      .modeLabel { font-size: 12px; color: var(--muted); text-transform: uppercase; letter-spacing: 0.06em; }
      .toggleWrap { display: inline-flex; align-items: center; gap: 10px; }
      .toggleSwitch { position: relative; width: 52px; height: 28px; background: #dbe7f2; border-radius: 999px; cursor: pointer; border: 1px solid #c7d9e8; }
      .toggleSwitch input { position: absolute; opacity: 0; width: 0; height: 0; }
      .toggleKnob { position: absolute; top: 3px; left: 3px; width: 22px; height: 22px; background: #ffffff; border-radius: 50%; box-shadow: 0 2px 6px rgba(15, 23, 42, 0.2); transition: transform 0.2s ease; }
      .toggleSwitch input:checked + .toggleKnob { transform: translateX(24px); }
      .modeValue { font-weight: 600; font-size: 13px; color: var(--text); } */
      .formGrid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 12px; }
      label { font-size: 13px; color: var(--muted); }
      input, select, textarea { width: 100%; border: 1px solid var(--border); border-radius: 10px; padding: 10px 12px; font: inherit; background: #ffffff; }
      textarea { resize: vertical; min-height: 120px; overflow: auto; }
      .questionBox { border: 1px solid var(--border); border-radius: 12px; padding: 12px; min-height: 90px; max-height: 160px; overflow: auto; background: #ffffff; }
      .chatHistory { border: 1px solid var(--border); border-radius: 12px; padding: 12px; min-height: 220px; height: 100%; overflow: auto; background: #ffffff; }
      .chatEntry { padding: 10px 12px; border-radius: 10px; margin-bottom: 10px; font-size: 14px; line-height: 1.45; }
      .chatEntry:last-child { margin-bottom: 0; }
      .chatEntry.user { background: #eef6ff; border: 1px solid #d7e7ff; }
      .chatEntry.ai { background: #f8fafc; border: 1px solid var(--border); }
      .assessmentDebug { border: 1px solid var(--border); border-radius: 12px; background: #ffffff; padding: 12px; }
      .assessmentDebugHeader { display: flex; align-items: center; justify-content: space-between; gap: 10px; margin-bottom: 8px; }
      .assessmentDebugTitle { font-size: 13px; font-weight: 700; color: var(--text); }
      .assessmentDebugLog { font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace; font-size: 12px; line-height: 1.45; white-space: pre-wrap; max-height: 200px; overflow: auto; background: #f8fafc; border: 1px solid var(--border); border-radius: 10px; padding: 10px; }
      .quizHeader { font-size: 18px; font-weight: 700; margin: 0 0 8px; }
      .assessmentLayout {
        display: grid;
        grid-template-columns: minmax(0, 1fr) 220px;
        gap: 18px;
        align-items: stretch;
        padding-top: 72px;
        height: calc(100vh - 220px - 72px);
      }
      .assessmentMain { display: grid; gap: 14px; grid-template-rows: auto auto 1fr auto; min-height: 0; }
      .assessmentSide { display: grid; gap: 14px; align-content: start; }
      .assessmentSide button { width: 100%; }
      .quizHeaderRow { display: flex; align-items: center; justify-content: space-between; gap: 12px; }
      .answerWrap { display: grid; grid-template-columns: minmax(0, 1fr); gap: 12px; align-items: end; }
      .answerStack { display: grid; gap: 6px; grid-template-rows: auto 1fr; min-height: 0; }
      .answerStack textarea { height: 100%; max-height: 240px; }
      .answerWrap.is-locked textarea { background: #e2e8f0; color: #64748b; }
      .evaluateSide { align-self: start; width: 100%; }
      .nextFloating { position: fixed; right: 24px; bottom: 24px; z-index: 70; }
      .feedbackSection { display: grid; grid-template-rows: auto minmax(0, 1fr); min-height: 0; }
      .hintBtn { background: #0b8f64; }
      .hintBtn:hover:not(:disabled) { background: #0a7a55; }
      .actions { display: flex; gap: 10px; flex-wrap: wrap; justify-content: flex-end; }
      .dictationControls { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
      .dictationStatus { font-size: 12px; color: var(--muted); }
      .audioMeter { position: relative; width: 120px; height: 8px; background: #e2e8f0; border-radius: 999px; overflow: hidden; }
      .audioMeterFill { position: absolute; left: 0; top: 0; bottom: 0; width: 0%; background: #22c55e; transition: width 0.05s linear; }
      .audioMeter.active .audioMeterFill { background: #22c55e; }
      .audioMeter.inactive .audioMeterFill { background: #94a3b8; }
      .playbackWidget { display: inline-flex; align-items: center; gap: 8px; min-width: 220px; }
      .playbackTrack { position: relative; width: 160px; height: 8px; background: #e2e8f0; border-radius: 999px; overflow: hidden; }
      .playbackFill { position: absolute; left: 0; top: 0; bottom: 0; width: 0%; background: #7fb6dc; transition: width 0.05s linear; }
      .playbackIndicator { position: absolute; top: -4px; left: 0%; width: 3px; height: 16px; background: var(--primary-dark); transform: translateX(-50%); border-radius: 2px; transition: left 0.05s linear; }
      .playbackDot { position: absolute; top: 50%; left: 0%; width: 12px; height: 12px; border-radius: 50%; background: var(--primary); transform: translate(-50%, -50%); box-shadow: 0 0 0 2px #ffffff; transition: left 0.05s linear; }
      .playbackTime { font-size: 11px; color: var(--muted); min-width: 62px; text-align: right; }
      .playbackWidget.disabled { opacity: 0.5; }
      button { appearance: none; border: none; border-radius: 999px; padding: 10px 16px; font-size: 14px; font-weight: 600; background: var(--primary); color: #ffffff; cursor: pointer; transition: background 0.2s ease; }
      button.secondary { background: #ffffff; color: var(--primary); border: 1px solid #c7d9e8; }
      button:disabled { opacity: 0.55; cursor: not-allowed; }
      button:hover:not(:disabled) { background: var(--primary-dark); }
      button.secondary:hover:not(:disabled) { background: #eef6ff; }
      .hidden { display: none !important; }
      .pageTitleRow { display: flex; align-items: center; justify-content: flex-start; gap: 12px; flex-wrap: wrap; }
      .floatingButtonGroup { position: static; z-index: 50; display: flex; gap: 10px; flex-wrap: wrap; }
      .hintOverlay {
        position: fixed;
        inset: 0;
        background: rgba(15, 23, 42, 0.6);
        display: grid;
        place-items: center;
        z-index: 90;
        padding: 20px;
      }
      .hintModal {
        width: min(520px, 92vw);
        background: #ffffff;
        border-radius: 16px;
        border: 1px solid var(--border);
        box-shadow: 0 20px 40px rgba(15, 23, 42, 0.2);
        padding: 20px;
        display: grid;
        gap: 12px;
      }
      .hintHeader { display: flex; align-items: center; justify-content: space-between; gap: 10px; }
      .hintTitle { font-weight: 700; font-size: 16px; }
      .hintBody { font-size: 14px; line-height: 1.5; color: var(--text); }
      .pageTitle {
        font-size: 22px;
        font-weight: 700;
        margin: 0 0 16px;
      }
      .welcomeScreen {
        position: relative;
        overflow: hidden;
        background: #f6f6f6;
      }
      .welcomeContent {
        position: relative;
        z-index: 2;
        text-align: center;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 12px;
        padding: 48px 18px 36px;
      }
      .welcomeTitle {
        font-weight: 700;
        font-size: 20px;
      }
      .welcomeSubtext {
        font-size: 15px;
        color: var(--muted);
      }
      .welcomeBody {
        font-size: 16px;
        line-height: 1.6;
        color: var(--text);
      }
      .welcomeBody p {
        margin: 0 0 8px;
      }
      .welcomeBody p:last-child {
        margin-bottom: 0;
      }
      .welcomeLogo {
        position: absolute;
        top: 18px;
        right: 22px;
        width: 160px;
        height: auto;
        z-index: 3;
      }
      .appLogo {
        position: fixed;
        top: 18px;
        right: 22px;
        width: 160px;
        height: auto;
        z-index: 6;
      }
      .welcomeArt {
        position: absolute;
        width: 120px;
        height: auto;
        z-index: 1;
      }
      .welcomeArt.topLeft {
        top: 16px;
        left: 16px;
        transform: rotate(180deg);
      }
      .welcomeArt.bottomLeft {
        bottom: 16px;
        left: 16px;
      }
      .collectCard {
        background: #f6f6f6 url("/RPL%20Bot%20Artwork/RPL%20Background.jpg") no-repeat center center;
        background-size: cover;
        color: var(--text);
        border-color: var(--border);
      }
      .collectCard label,
      .collectCard .status,
      .collectCard .stepTitle {
        color: var(--text);
      }
      #quizCard {
        background: transparent;
        border: none;
        box-shadow: none;
        padding: 0;
      }
      .collectHeader {
        display: grid;
        gap: 6px;
        margin-bottom: 18px;
      }
      .collectGreeting {
        font-size: 18px;
        font-weight: 600;
      }
      .collectSubtitle {
        font-style: italic;
        color: var(--muted);
        font-size: 14px;
      }
      .collectTop {
        display: grid;
        grid-template-columns: minmax(220px, 0.9fr) minmax(240px, 1.05fr) minmax(240px, 1.05fr);
        gap: 18px;
        align-items: start;
        margin-bottom: 18px;
      }
      .collectBottom {
        display: grid;
        grid-template-columns: repeat(3, minmax(240px, 1fr));
        gap: 16px;
        align-items: start;
      }
      .collectStep {
        display: grid;
        grid-template-columns: auto 1fr;
        gap: 12px;
        align-items: start;
      }
      .stepBadge {
        width: 28px;
        height: 28px;
        border-radius: 50%;
        background: #f97316;
        color: #fff;
        font-weight: 700;
        display: grid;
        place-items: center;
        font-size: 13px;
      }
      .stepContent {
        display: grid;
        gap: 10px;
      }
      .collectBottom .stepContent {
        width: 100%;
        max-width: 260px;
      }
      .collectBottom .stepContent select,
      .collectBottom .stepContent input,
      .collectBottom .stepContent button {
        width: 100%;
      }
      .collectPreview {
        display: grid;
        gap: var(--camera-gap);
        justify-items: start;
        grid-template-rows: var(--camera-height) var(--camera-select-height);
      }
      .collectCapture {
        display: grid;
        gap: 12px;
        justify-items: start;
        align-content: start;
      }
      .collectVideo {
        width: 100%;
        max-width: var(--camera-width);
        height: var(--camera-height);
        border-radius: 12px;
        border: 1px solid #4b5563;
        background: #0f172a;
        object-fit: cover;
      }
      .collectSelectRow {
        width: 100%;
        max-width: var(--camera-width);
        height: var(--camera-select-height);
        display: grid;
        align-items: center;
      }
      .collectSelectRow select,
      .collectCard input,
      .collectCard select {
        background: #ffffff;
        color: #0f172a;
      }
      .collectAction {
        display: grid;
        gap: 12px;
        justify-items: center;
      }
      .collectAvatar {
        width: 100%;
        max-width: var(--camera-width);
        height: calc(var(--camera-height) + var(--camera-select-height) + var(--camera-gap));
        border-radius: 12px;
        border: 1px solid #4b5563;
        background: rgba(255, 255, 255, 0.08);
        display: grid;
        place-items: center;
        overflow: hidden;
        position: relative;
      }
      .collectAvatar img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        border-radius: 12px;
      }
      .collectPlaceholder {
        position: absolute;
        inset: 0;
        display: grid;
        place-items: center;
        background: #2f3b45;
      }
      .collectPlaceholder::before {
        content: "";
        width: 54px;
        height: 54px;
        border-radius: 50%;
        background: #4b5563;
        display: block;
        margin-bottom: 8px;
        box-shadow: 0 60px 0 8px #4b5563;
      }
      .collectCard button.secondary {
        background: #ffffff;
        color: #0b6ea9;
      }
      .collectCard button {
        justify-self: start;
      }
      @media (max-width: 900px) {
        .collectTop {
          grid-template-columns: 1fr;
        }
        .collectAction {
          justify-items: start;
        }
        .assessmentLayout {
          grid-template-columns: 1fr;
          padding-top: 64px;
          height: calc(100vh - 220px - 64px);
        }
        .assessmentSide {
          grid-template-columns: repeat(2, minmax(0, 1fr));
        }
        .answerWrap {
          grid-template-columns: 1fr;
        }
        .evaluateSide {
          width: 100%;
        }
        .nextFloating {
          position: static;
          width: 100%;
        }
      }
    </style>
  </head>
  <body>
    <div class="page">
      <div id="welcomeScreen" class="card welcomeScreen" style="margin:0 0 18px;">
        <img
          class="welcomeLogo"
          src="/RPL%20Bot%20Artwork/2024_logo_black_transparent_outline_HRES.png"
          alt="AAMC Training Group"
        />
        
        <div class="welcomeContent">
          <div class="welcomeTitle" id="welcomeTitle">Welcome to the AAMC RPL Quiz</div>
          <div class="welcomeBody" id="welcomeBody">
            <p>Initialising…</p>
          </div>
          <button id="welcomeContinueBtn" disabled>Continue</button>
        </div>
      </div>

      <div id="postWelcomePage" class="hidden">
        <img
          class="appLogo"
          src="/RPL%20Bot%20Artwork/2024_logo_black_transparent_outline_HRES.png"
          alt="AAMC Training Group"
        />
        <div class="pageTitleRow">
          <div class="pageTitle" id="postWelcomeTitle">Collect User Data</div>
          <div class="floatingButtonGroup">
            <button id="transcriptBtn" class="secondary">Transcript</button>
            <button id="responseBtn" class="secondary" disabled>Response</button>
            <button id="questionBtn" class="secondary" disabled>Question</button>
            <button id="tableBtn" class="secondary" disabled>Table</button>
            <button id="finalBtn" class="secondary">Final</button>
          </div>
        </div>
        <div id="initScreen" class="card" style="margin:0 0 18px;">
          <div style="font-weight:700; margin-bottom:6px;">Initialising</div>
          <div class="status" id="initStatus">Please wait while we prepare your assessment.</div>
        </div>

        <div class="shell hidden" id="appShell">
          <div class="header hidden">
            <div style="font-weight:700; text-decoration:underline;">AAMC RPL Quiz - V0.1</div>
          </div>

        <div class="progressRow hidden" id="progressRow"></div>

        <div id="setupCard" class="card collectCard">
          <div class="collectHeader">
            <div class="collectGreeting" id="collectGreeting">Hello and welcome to your RPL Assessment</div>
            <div class="collectSubtitle">AI-Powered RPL Knowledge &amp; Experience Evaluation</div>
          </div>
          <div class="status" id="status">Idle.</div>
          <div class="collectTop">
            <div class="collectStep">
              <div class="stepBadge">1</div>
              <div class="stepContent">
                <div class="stepTitle">
                  You can do this as many times as you like. First, take your photo. When you are
                  happy with the result, continue to confirm your details below.
                </div>
                <button id="takePhotoBtn">Take Photo</button>
              </div>
            </div>
            <div class="collectPreview">
              <video id="cameraPreview" class="collectVideo" autoplay playsinline muted></video>
              <div class="collectSelectRow">
                <select id="cameraSelect">
                  <option value="">Detecting webcams…</option>
                </select>
              </div>
            </div>
            <div class="collectCapture">
              <div class="collectAvatar">
                <div id="photoPlaceholder" class="collectPlaceholder"></div>
                <img id="photoPreview" class="hidden" alt="Captured photo preview" />
              </div>
            </div>
          </div>
          <div class="collectBottom">
            <div class="collectStep">
              <div class="stepBadge">2</div>
              <div class="stepContent">
                <div class="stepTitle">
                  From the drop-down list below, choose the industry you work in, and select
                  “Confirm Industry”.
                </div>
                <select id="industry">
                  <option value="">Select industry</option>
                  <option>Banking</option>
                  <option>Lending</option>
                  <option>Mortgage Broking</option>
                  <option>Finance Broking</option>
                </select>
                <button id="confirmIndustryBtn" class="secondary">Confirm Industry</button>
              </div>
            </div>
            <div class="collectStep">
              <div class="stepBadge">3</div>
              <div class="stepContent">
                <div class="stepTitle">Type in your job title and select “Confirm Job Title”.</div>
                <input id="jobTitle" type="text" placeholder="Type your job title here" />
                <button id="confirmJobTitleBtn" class="secondary">Confirm Job Title</button>
              </div>
            </div>
            <div class="collectStep">
              <div class="stepBadge">4</div>
              <div class="stepContent">
                <div class="stepTitle">
                  You can still update your photo, industry and job title, but if you are ready
                  please press the button below.
                </div>
                <button id="beginBtn">Begin The Assessment</button>
              </div>
            </div>
          </div>
          <canvas id="photoCanvas" class="hidden"></canvas>
        </div>

        <div id="quizCard" class="card hidden">
          <div class="assessmentLayout">
            <div class="assessmentMain">
              <div class="quizHeaderRow">
                <div class="quizHeader" id="headerTitle">Compliance - Question 1 of 0 - Attempt 1</div>
                <button id="showHintBtn" class="hintBtn secondary">Show Hint</button>
              </div>
              <div class="questionBox" id="questionText"></div>
              <div class="answerWrap">
                <div class="answerStack">
                  <strong>Your answer</strong>
                  <textarea id="answerInput" placeholder="Type your answer here..."></textarea>
                </div>
              </div>
              <div class="feedbackSection">
                <strong>Feedback</strong>
                <div class="chatHistory" id="chatHistory"></div>
              </div>
            </div>
            <div class="assessmentSide">
              <button id="evaluateBtn" class="evaluateSide">Evaluate</button>
              <button id="dictateBtn" class="secondary">Start Transcription</button>
              <button id="playbackBtn" class="secondary" disabled>Playback</button>
              <div class="audioMeter inactive" id="dictationMeter" title="Mic level">
                <div class="audioMeterFill" id="dictationMeterFill"></div>
              </div>
              <div class="playbackWidget disabled" id="playbackWidget">
                <div class="playbackTrack">
                  <div class="playbackFill" id="playbackFill"></div>
                  <div class="playbackIndicator" id="playbackIndicator"></div>
                  <div class="playbackDot" id="playbackDot"></div>
                </div>
                <div class="audioMeter inactive" id="playbackMeter" title="Playback level">
                  <div class="audioMeterFill" id="playbackMeterFill"></div>
                </div>
                <div class="playbackTime" id="playbackTime">0:00</div>
              </div>
              <span class="dictationStatus" id="dictationStatus">Dictation idle.</span>
            </div>
          </div>
          <button id="nextBtn" class="secondary nextFloating" disabled>Next</button>
        </div>
      </div>
    </div>

    <div id="hintOverlay" class="hintOverlay hidden" role="dialog" aria-modal="true" aria-labelledby="hintTitle">
      <div class="hintModal">
        <div class="hintHeader">
          <div class="hintTitle" id="hintTitle">Hint</div>
          <button id="hintCloseBtn" class="secondary">Close</button>
        </div>
        <div class="hintBody" id="hintBody">No hint available.</div>
      </div>
    </div>

    <script>
      const questionsUrl =
        "https://default4f0de57b35694b51b8c8b1dadd7ba8.19.environment.api.powerplatform.com:443/powerautomate/automations/direct/workflows/8feea7df352a455d9efde46977446910/triggers/manual/paths/invoke?api-version=1&sp=%2Ftriggers%2Fmanual%2Frun&sv=1.0&sig=AF-53thnNRJd9IxzY55POQzrW8owJ2SA6EhRycxtTEY";
      const PROMPTS_URL = "/prompts.json";

      const statusEl = document.getElementById("status");
      const headerTitleEl = document.getElementById("headerTitle");
      const setupCard = document.getElementById("setupCard");
      const quizCard = document.getElementById("quizCard");
      const fullNameEl = document.getElementById("fullName");
      const industryEl = document.getElementById("industry");
      const jobTitleEl = document.getElementById("jobTitle");
      const beginBtn = document.getElementById("beginBtn");
      const collectGreetingEl = document.getElementById("collectGreeting");
      const cameraSelectEl = document.getElementById("cameraSelect");
      const takePhotoBtn = document.getElementById("takePhotoBtn");
      const confirmIndustryBtn = document.getElementById("confirmIndustryBtn");
      const confirmJobTitleBtn = document.getElementById("confirmJobTitleBtn");
      const cameraPreviewEl = document.getElementById("cameraPreview");
      const photoPreviewEl = document.getElementById("photoPreview");
      const photoCanvasEl = document.getElementById("photoCanvas");
      const photoPlaceholderEl = document.getElementById("photoPlaceholder");

      const questionTextEl = document.getElementById("questionText");
      const chatHistoryEl = document.getElementById("chatHistory");
      const debugSectionEl = document.getElementById("debugSection");
      const debugLogEl = document.getElementById("debugLog");
      const welcomeScreenEl = document.getElementById("welcomeScreen");
      const welcomeTitleEl = document.getElementById("welcomeTitle");
      const welcomeBodyEl = document.getElementById("welcomeBody");
      const welcomeContinueBtn = document.getElementById("welcomeContinueBtn");
      const welcomeDebugLogEl = null;
      const postWelcomePageEl = document.getElementById("postWelcomePage");
      const postWelcomeTitleEl = document.getElementById("postWelcomeTitle");
      const initScreenEl = document.getElementById("initScreen");
      const initStatusEl = document.getElementById("initStatus");
      const initDebugSectionEl = document.getElementById("initDebugSection");
      const initDebugLogEl = document.getElementById("initDebugLog");
      const appShellEl = document.getElementById("appShell");
      const progressRowEl = document.getElementById("progressRow");
      const micSelectEl = document.getElementById("micSelect");
      const micStatusEl = document.getElementById("micStatus");
      const answerInputEl = document.getElementById("answerInput");
      const dictateBtn = document.getElementById("dictateBtn");
      const playbackBtn = document.getElementById("playbackBtn");
      const dictationMeterEl = document.getElementById("dictationMeter");
      const dictationMeterFillEl = document.getElementById("dictationMeterFill");
      const playbackWidgetEl = document.getElementById("playbackWidget");
      const playbackFillEl = document.getElementById("playbackFill");
      const playbackIndicatorEl = document.getElementById("playbackIndicator");
      const playbackDotEl = document.getElementById("playbackDot");
      const playbackTimeEl = document.getElementById("playbackTime");
      const playbackMeterEl = document.getElementById("playbackMeter");
      const playbackMeterFillEl = document.getElementById("playbackMeterFill");
      const dictationStatusEl = document.getElementById("dictationStatus");
      const assessmentDebugLogEl = document.getElementById("assessmentDebugLog");
      const evaluateBtn = document.getElementById("evaluateBtn");
      const nextBtn = document.getElementById("nextBtn");
      const finalBtn = document.getElementById("finalBtn");
      const transcriptBtn = document.getElementById("transcriptBtn");
      const responseBtn = document.getElementById("responseBtn");
      const questionBtn = document.getElementById("questionBtn");
      const tableBtn = document.getElementById("tableBtn");
      const showHintBtn = document.getElementById("showHintBtn");
      const hintOverlayEl = document.getElementById("hintOverlay");
      const hintCloseBtn = document.getElementById("hintCloseBtn");
      const hintBodyEl = document.getElementById("hintBody");
      const answerWrapEl = document.querySelector(".answerWrap");
      // const modeToggleEl = document.getElementById("modeToggle");
      // const modeLabelEl = document.getElementById("modeLabel");

      let questions = [];
      let currentIndex = 0;
      let fullName = "";
      let firstName = "";
      let industry = "";
      let jobTitle = "";
      let isDictating = false;
      let finalTranscript = "";
      let manualOverride = false;
      let aiMode = "router";
      const MAX_ATTEMPTS = 3;
      let currentAttempts = 0;
      let currentResponses = [];
      let audioCtx = null;
      let micStream = null;
      let micSourceNode = null;
      let mediaRecorder = null;
      let recordedChunks = [];
      let lastResponseRecording = null;
      let lastPlaybackRecording = null;
      let lastPlaybackUrl = "";
      let playbackAudio = null;
      let playbackIsPlaying = false;
      let lastPlaybackDuration = 0;
      let playbackLocked = false;
      let cameraStream = null;
      let lastPhotoDataUrl = "";
      let dictationAnalyser = null;
      let dictationMeterRaf = null;
      let playbackAudioCtx = null;
      let playbackAnalyser = null;
      let playbackMeterRaf = null;
      let speechRecognizer = null;
      let speechPushStream = null;
      let speechTapNode = null;
      let speechTapGain = null;
      let speechSilentGain = null;
      let speechTokenInfo = { token: "", region: "", expiresAt: 0 };
      let fullTranscript = "";
      let assessmentStartAt = null;
      let transcriptQuestions = [];
      let resumeTranscriptText = "";
      let resumeApplied = false;
      let resumeCurrentQuestionNumber = null;
      let resumeLoadPromise = null;
      let lastStudentContextResponseText = "";
      let lastQuestionResponseText = "";
      let promptTemplates = null;
      let welcomeMode = "new";
      let isUiLocked = false;
      let hintOpen = false;
      let lockedButtonStates = null;
      let attemptLocked = false;
      let attemptLockStates = null;
      const DEFAULT_FULL_NAME = "Billy Broker";
      const DEFAULT_GIVEN_NAME = "Billy";
      const DEFAULT_CONTACT_ID = "123456";
      const MIC_STORAGE_KEY = "rplMicDeviceId";

      const setStatus = (message) => {
        statusEl.textContent = message;
      };

      const setCollectStepsEnabled = (state) => {
        if (industryEl) industryEl.disabled = !state.industry;
        if (confirmIndustryBtn) confirmIndustryBtn.disabled = !state.industry;
        if (jobTitleEl) jobTitleEl.disabled = !state.jobTitle;
        if (confirmJobTitleBtn) confirmJobTitleBtn.disabled = !state.jobTitle;
        if (beginBtn) beginBtn.disabled = !state.begin;
      };

      const updateCollectGreeting = () => {
        const ctx = getStudentContext();
        if (collectGreetingEl) {
          collectGreetingEl.textContent = `Hello ${ctx.fullName} and welcome to your RPL Assessment`;
        }
      };

      const isAdminDebugEnabled = () => window.location?.hash === "#admin";

      const updateDebugVisibility = () => {
        if (debugSectionEl) debugSectionEl.classList.remove("hidden");
        if (initDebugSectionEl) initDebugSectionEl.classList.remove("hidden");
        
      };

      const logWelcomeDebug = () => {};

      const setWelcomeResumeData = (data) => {
        if (!data || typeof data !== "object") return;
        const combined = pickFirstValue(data["Industry,Job Title"], data.industryJobTitle);
        const currentQuestionText = pickFirstValue(data["Current Question"], data.currentQuestion);
        const transcriptText = pickFirstValue(data["Full Transcription"], data.fullTranscription);

        let industryValue = combined;
        let jobValue = "";
        if (combined) {
          const commaIndex = combined.indexOf(",");
          if (commaIndex >= 0) {
            industryValue = combined.slice(0, commaIndex).trim();
            jobValue = combined.slice(commaIndex + 1).trim();
          }
        }

        if (industryValue) {
          industry = industryValue;
          if (industryEl) industryEl.value = industryValue;
        }
        if (jobValue) {
          jobTitle = jobValue;
          if (jobTitleEl) jobTitleEl.value = jobValue;
        }

        resumeTranscriptText = transcriptText || "";
        const parsedNumber = Number.parseInt(currentQuestionText, 10);
        resumeCurrentQuestionNumber = Number.isFinite(parsedNumber) ? parsedNumber : null;
      };

      const pickFirstValue = (...candidates) => {
        for (const candidate of candidates) {
          if (candidate === undefined || candidate === null) continue;
          const text = typeof candidate === "string" ? candidate : String(candidate);
          if (text && text.trim()) return text.trim();
        }
        return "";
      };

      const setMicStatus = (message) => {
        if (micStatusEl) micStatusEl.textContent = message;
      };

      const stopCameraStream = () => {
        if (!cameraStream) return;
        cameraStream.getTracks().forEach((track) => track.stop());
        cameraStream = null;
        if (cameraPreviewEl) cameraPreviewEl.srcObject = null;
      };

      const populateCameras = async () => {
        if (!cameraSelectEl || !navigator?.mediaDevices?.enumerateDevices) return;
        try {
          const devices = await navigator.mediaDevices.enumerateDevices();
          const cams = devices.filter((device) => device.kind === "videoinput");
          if (!cams.length) {
            cameraSelectEl.innerHTML = "<option value=\"\">No webcams found</option>";
            cameraSelectEl.disabled = true;
            return;
          }
          cameraSelectEl.disabled = false;
          const selectedValue = cameraSelectEl.value;
          cameraSelectEl.innerHTML = "";
          cams.forEach((cam, index) => {
            const option = document.createElement("option");
            option.value = cam.deviceId;
            option.textContent = cam.label || `Webcam ${index + 1}`;
            cameraSelectEl.appendChild(option);
          });
          if (selectedValue && cams.some((cam) => cam.deviceId === selectedValue)) {
            cameraSelectEl.value = selectedValue;
          } else {
            cameraSelectEl.value = cams[0].deviceId;
          }
        } catch (error) {
          logDebug(`Camera list error: ${error?.message || String(error)}`);
        }
      };

      const startCamera = async () => {
        if (!navigator?.mediaDevices?.getUserMedia) {
          setStatus("Camera access is not supported in this browser.");
          return;
        }
        const deviceId = cameraSelectEl?.value;
        stopCameraStream();
        try {
          const constraints = {
            video: deviceId ? { deviceId: { exact: deviceId } } : true,
            audio: false,
          };
          cameraStream = await navigator.mediaDevices.getUserMedia(constraints);
          if (cameraPreviewEl) cameraPreviewEl.srcObject = cameraStream;
          if (photoPreviewEl) photoPreviewEl.classList.add("hidden");
          if (photoPlaceholderEl) photoPlaceholderEl.classList.remove("hidden");
          setStatus("Camera ready. Press Take Photo again to capture.");
        } catch (error) {
          setStatus(error?.message || String(error));
        }
      };

      const capturePhoto = () => {
        if (!cameraStream || !cameraPreviewEl || !photoCanvasEl) return;
        const track = cameraStream.getVideoTracks()[0];
        const settings = track.getSettings();
        const width = settings.width || cameraPreviewEl.videoWidth || 1280;
        const height = settings.height || cameraPreviewEl.videoHeight || 720;
        photoCanvasEl.width = width;
        photoCanvasEl.height = height;
        const context = photoCanvasEl.getContext("2d");
        context.drawImage(cameraPreviewEl, 0, 0, width, height);
        lastPhotoDataUrl = photoCanvasEl.toDataURL("image/jpeg", 0.9);
        if (photoPreviewEl) {
          photoPreviewEl.src = lastPhotoDataUrl;
          photoPreviewEl.classList.remove("hidden");
        }
        if (photoPlaceholderEl) photoPlaceholderEl.classList.add("hidden");
        setStatus("Photo captured.");
        setCollectStepsEnabled({ industry: true, jobTitle: false, begin: false });
      };

      const isNoTranscriptResponse = (value) => {
        if (!value) return false;
        if (typeof value !== "string") return false;
        const normalized = value.trim().toLowerCase();
        return normalized === "no transcript" || normalized === "no transcription";
      };

      const populateMicrophones = async () => {
        if (!micSelectEl) return;
        if (!navigator?.mediaDevices?.enumerateDevices) {
          micSelectEl.innerHTML = "<option value=\"\">Microphone list not supported</option>";
          micSelectEl.disabled = true;
          setMicStatus("Microphone selection is not supported in this browser.");
          return;
        }

        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          stream.getTracks().forEach((track) => track.stop());
        } catch (err) {
          setMicStatus("Microphone access blocked. Allow access to list devices.");
        }

        try {
          const devices = await navigator.mediaDevices.enumerateDevices();
          const mics = devices.filter((device) => device.kind === "audioinput");
          const savedId = localStorage.getItem(MIC_STORAGE_KEY) || "";

          if (!mics.length) {
            micSelectEl.innerHTML = "<option value=\"\">No microphones found</option>";
            micSelectEl.disabled = true;
            setMicStatus("No microphone devices detected.");
            return;
          }

          micSelectEl.disabled = false;
          micSelectEl.innerHTML = "";
          mics.forEach((mic, index) => {
            const option = document.createElement("option");
            option.value = mic.deviceId;
            option.textContent = mic.label || `Microphone ${index + 1}`;
            micSelectEl.appendChild(option);
          });

          const selectedId = mics.some((mic) => mic.deviceId === savedId) ? savedId : mics[0].deviceId;
          micSelectEl.value = selectedId;
          localStorage.setItem(MIC_STORAGE_KEY, selectedId);
          setMicStatus("Microphone selection saved.");
        } catch (err) {
          micSelectEl.innerHTML = "<option value=\"\">Unable to load microphones</option>";
          micSelectEl.disabled = true;
          setMicStatus(err?.message || String(err));
        }
      };

      const applyUrlStudentContext = () => {
        if (typeof window.URLSearchParams !== "function") return {};
        try {
          const params = new URLSearchParams(window.location?.search || "");
          const fullName = params.get("fullName") ?? params.get("FullName") ?? params.get("studentName") ?? params.get("StudentName");
          const givenName = params.get("givenName") ?? params.get("GivenName");
          const contactId = params.get("contactId") ?? params.get("ContactID") ?? params.get("ContactId");

          const nextInfo = {
            ...(typeof window.RPLStudentInfo === "object" && window.RPLStudentInfo ? window.RPLStudentInfo : {}),
          };
          let mutated = false;

          if (fullName && fullName.trim()) {
            nextInfo.fullName = fullName.trim();
            nextInfo.studentName = fullName.trim();
            mutated = true;
          }
          if (givenName && givenName.trim()) {
            nextInfo.givenName = givenName.trim();
            mutated = true;
          }
          if (contactId && contactId.trim()) {
            nextInfo.contactId = contactId.trim();
            mutated = true;
          }

          if (mutated) {
            window.RPLStudentInfo = nextInfo;
            if (document.body?.dataset) {
              if (nextInfo.fullName || nextInfo.studentName) {
                document.body.dataset.fullName = nextInfo.fullName || nextInfo.studentName;
              }
              if (nextInfo.givenName) {
                document.body.dataset.givenName = nextInfo.givenName;
              }
              if (nextInfo.contactId) {
                document.body.dataset.contactId = nextInfo.contactId;
              }
            }
          }
          return nextInfo;
        } catch (err) {
          logDebug(`Unable to parse student URL params: ${err?.message || String(err)}`);
          return {};
        }
      };

      const getStudentContext = () => {
        const bodyDataset = document.body?.dataset || {};
        const studentInfo = window.RPLStudentInfo || window.rplStudentInfo || window.studentInfo || {};
        const fullName = pickFirstValue(
          studentInfo.fullName,
          studentInfo.studentName,
          bodyDataset.fullName,
          bodyDataset.studentName
        );
        const givenName = pickFirstValue(
          studentInfo.givenName,
          bodyDataset.givenName
        );
        const contactId = pickFirstValue(
          studentInfo.contactId,
          bodyDataset.contactId
        );
        return {
          fullName: fullName || DEFAULT_FULL_NAME,
          givenName: givenName || DEFAULT_GIVEN_NAME,
          contactId: contactId || DEFAULT_CONTACT_ID,
        };
      };

      const updateStudentContextBanner = () => {
        const fullNameEl = document.getElementById("studentFullName");
        const givenNameEl = document.getElementById("studentGivenName");
        const contactIdEl = document.getElementById("studentContactId");
        const ctx = getStudentContext();
        if (fullNameEl) fullNameEl.textContent = `Full Name: ${ctx.fullName}`;
        if (givenNameEl) givenNameEl.textContent = `Given Name: ${ctx.givenName}`;
        if (contactIdEl) contactIdEl.textContent = `Contact ID: ${ctx.contactId}`;
      };

      const initFullTranscript = () => {
        const ctx = getStudentContext();
        const stamp = new Date().toLocaleString();
        fullTranscript = `${ctx.fullName}- ${ctx.contactId} - RPL Full Transcript\n\nDate : ${stamp}\n\n`;
        window.RPLFullTranscript = fullTranscript;
      };

      const appendToTranscript = (role, text) => {
        if (!text) return;
        if (!fullTranscript) initFullTranscript();
        fullTranscript += `[${role}] ${text}\n`;
        window.RPLFullTranscript = fullTranscript;
      };

      const formatDate = (value) => value.toLocaleDateString();
      const formatDateTime = (value) => {
        if (value instanceof Date) return value.toLocaleString();
        if (typeof value === "string" && value.trim()) return value.trim();
        return "";
      };

      const getOverallAssessment = (feedback) => {
        if (!feedback) return "";
        const normalized = feedback.toLowerCase();
        const needsMoreInfoSignals = [
          "add more",
          "more detail",
          "more details",
          "not effectively",
          "does not",
          "not yet",
          "doesn't",
          "did not",
          "cannot",
          "please provide",
          "please add",
          "does not address",
          "not addressed",
          "if you cannot add any more",
          "cannot add any more"
        ];
        if (needsMoreInfoSignals.some((signal) => normalized.includes(signal))) {
          return "NEEDS MORE INFO";
        }
        if (normalized.includes("proceed to the next question") || normalized.includes("sufficient")) {
          return "SATISFACTORY";
        }
        return "SATISFACTORY";
      };

      const ensureTranscriptQuestion = (index, questionText) => {
        if (!transcriptQuestions[index]) {
          transcriptQuestions[index] = {
            questionText: questionText || "",
            attempts: [],
            summary: "",
          };
        }
        return transcriptQuestions[index];
      };

      const parseTranscriptQuestions = (transcriptText) => {
        if (!transcriptText) return [];
        const parsed = [];
        const questionRegex = /Question\s+(\d+):\s*([\s\S]*?)(?=\nQuestion\s+\d+:|$)/g;
        let match;
        while ((match = questionRegex.exec(transcriptText))) {
          const index = Math.max(0, parseInt(match[1], 10) - 1);
          const section = match[2] || "";
          const questionLine = (section.split("\n")[0] || "").trim();
          const summaryMatch = section.match(/Summary:\s*([\s\S]*?)(?=\n\n|\nOverall assessment:|\n-----------------------------)/i);
          const summary = summaryMatch ? summaryMatch[1].trim() : "";
          const attempts = [];
          const attemptsSection = section.split("-----------------------------")[1] || "";
          const attemptRegex = /\n([^\n]+) \(Attempt (\d+)\):\n([\s\S]*?)(?=\nAssessorBot:|\nSubmitted:|\n\n|\n-----------------------------|$)/g;
          let attemptMatch;
          while ((attemptMatch = attemptRegex.exec(attemptsSection))) {
            const tail = attemptsSection.slice(attemptMatch.index + attemptMatch[0].length);
            const feedbackMatch = tail.match(/^\n?AssessorBot:\n([\s\S]*?)(?=\nSubmitted:|\n\n|\n-----------------------------|$)/);
            const submittedMatch = tail.match(/Submitted:\s*([^\n]+)/);
            attempts.push({
              answer: (attemptMatch[3] || "").trim(),
              feedback: feedbackMatch ? feedbackMatch[1].trim() : "",
              submittedAt: submittedMatch ? submittedMatch[1].trim() : "",
            });
          }
          parsed[index] = {
            questionText: questionLine,
            attempts,
            summary,
          };
        }
        return parsed;
      };

      const parseCurrentQuestionValue = (rawText) => {
        if (!rawText) return "";
        if (typeof rawText !== "string") return String(rawText);
        try {
          const json = JSON.parse(rawText);
          const directValue =
            json?.Title ||
            json?.title ||
            json?.CurrentQuestion ||
            json?.currentQuestion ||
            json?.question ||
            json?.text ||
            "";
          if (typeof directValue === "string" && directValue.trim()) {
            return directValue;
          }
          const bodyValue = json?.body;
          if (typeof bodyValue === "string" && bodyValue.trim()) {
            try {
              const bodyJson = JSON.parse(bodyValue);
              const nestedValue =
                bodyJson?.Title ||
                bodyJson?.title ||
                bodyJson?.CurrentQuestion ||
                bodyJson?.currentQuestion ||
                bodyJson?.question ||
                bodyJson?.text ||
                bodyValue;
              return typeof nestedValue === "string" ? nestedValue : String(nestedValue || "");
            } catch {
              return bodyValue;
            }
          }
          return typeof json?.body === "string" ? json.body : String(json?.body || "");
        } catch {
          return rawText;
        }
      };

      const findQuestionIndexByTitle = (titleText) => {
        if (!titleText || !questions.length) return null;
        const normalized = String(titleText).trim().toLowerCase();
        if (!normalized) return null;
        const candidates = questions.map((question) =>
          (question?.Title || "").toString().trim().toLowerCase()
        );

        let index = candidates.findIndex((candidate) => candidate === normalized);
        if (index >= 0) return index;

        index = candidates.findIndex((candidate) =>
          candidate && (candidate.includes(normalized) || normalized.includes(candidate))
        );
        return index >= 0 ? index : null;
      };

      const findQuestionIndexByTitleNumber = (numberText) => {
        if (!numberText || !questions.length) return null;
        const normalized = String(numberText).trim();
        if (!normalized) return null;
        const index = questions.findIndex((question) => {
          const titleValue = question?.Title ?? "";
          const titleNumber = extractQuestionNumberFromText(titleValue);
          return titleNumber === normalized;
        });
        return index >= 0 ? index : null;
      };

      const findQuestionIndexByNumber = (numberText) => {
        if (!numberText || !questions.length) return null;
        const normalized = String(numberText).trim();
        if (!normalized) return null;
        const regex = new RegExp(`\\b${normalized}\\b`, "i");
        const candidates = questions.map((question) =>
          (question?.Title || question?.field_5 || "").toString()
        );
        const index = candidates.findIndex((candidate) => regex.test(candidate));
        return index >= 0 ? index : null;
      };

      const extractQuestionNumberFromText = (value) => {
        if (!value) return "";
        const text = String(value);
        const match = text.match(/\b(\d{1,3})\b/);
        return match ? match[1] : "";
      };

      const fetchCurrentQuestionFromWebhook = async () => {
        const ctx = getStudentContext();
        const payload = {
          FullName: ctx.fullName,
          ContactID: String(ctx.contactId),
          GivenName: ctx.givenName,
        };
        const url =
          "https://default63871d3cd05d49fa86b6420054699f.b4.environment.api.powerplatform.com:443/powerautomate/automations/direct/workflows/b1ff377a8f444df09e636aebeb258784/triggers/manual/paths/invoke?api-version=1&sp=%2Ftriggers%2Fmanual%2Frun&sv=1.0&sig=4pQKTsG4VbeKDS3UDU_3FDvE6WUItJxkJh7SZg1oOuc";

        logDebug("Fetching current question from webhook");
        logDebugDetail("Current question payload", payload);

        /*
        const response = await fetch(url, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        logDebugDetail("Current question HTTP status", `${response.status} ${response.statusText}`);
        const rawText = await response.text();
        lastQuestionResponseText = rawText || "";
        if (questionBtn) questionBtn.disabled = false;
        logDebugDetail("Current question response", rawText || "(empty)");
        return parseCurrentQuestionValue(rawText);
        */
        const rawText = "";
        lastQuestionResponseText = rawText;
        if (questionBtn) questionBtn.disabled = false;
        logDebugDetail("Current question response", rawText || "(empty)");
        return parseCurrentQuestionValue(rawText);
      };

      const findFirstUnansweredIndex = (entries, totalCount) => {
        for (let i = 0; i < totalCount; i += 1) {
          const entry = entries[i];
          if (!entry || !entry.summary) return i;
          if (getOverallAssessment(entry.summary) === "NEEDS MORE INFO") return i;
        }
        return totalCount;
      };

      const applyTranscriptResume = (transcriptText) => {
        if (!transcriptText || resumeApplied) return false;
        const parsed = parseTranscriptQuestions(transcriptText);
        if (parsed.length) {
          transcriptQuestions = parsed;
        }
        if (questions.length) {
          currentIndex = findFirstUnansweredIndex(transcriptQuestions, questions.length);
          resumeApplied = true;
          return true;
        }
        return false;
      };

      const setCompletedState = () => {
        setStatus("All questions completed.");
        headerTitleEl.textContent = "Compliance - Completed";
        questionTextEl.textContent = "You have completed all questions.";
        answerInputEl.value = "";
        evaluateBtn.disabled = true;
        nextBtn.disabled = true;
      };

      const buildFullTranscript = () => {
        const ctx = getStudentContext();
        const now = new Date();
        const startStamp = assessmentStartAt ? formatDateTime(assessmentStartAt) : formatDateTime(now);
        const industryValue = industry || industryEl?.value?.trim() || "";
        const jobTitleValue = jobTitle || jobTitleEl?.value?.trim() || "";
        let output =
`=============================
Assessment Transcript
=============================
Name: ${ctx.fullName}
Contact ID: ${ctx.contactId}
Assessment: RPL
Date: ${formatDate(now)}
Initial Start Date: ${startStamp}
Industry: ${industryValue || "N/A"}
Job Title: ${jobTitleValue || "N/A"}
=============================

`;

        const givenName = ctx.givenName || ctx.fullName;
        transcriptQuestions.forEach((entry, index) => {
          if (!entry) return;
          const summaryText = entry.summary || "";
          const overallAssessment = getOverallAssessment(summaryText);
          output += `Question ${index + 1}: ${entry.questionText}\n\n`;
          if (summaryText) {
            output += `Assessor summary: ${summaryText}\n\n`;
          }
          if (overallAssessment) {
            output += `Overall assessment: ${overallAssessment}.\n\n`;
          }
          output += `-----------------------------\n${entry.questionText}\n\n`;
          entry.attempts.forEach((attempt, attemptIndex) => {
            output += `${givenName} (Attempt ${attemptIndex + 1}):\n${attempt.answer}\n\n`;
            if (attempt.feedback) {
              output += `AssessorBot:\n${attempt.feedback}\n`;
            }
            if (attempt.submittedAt) {
              output += `Submitted: ${formatDateTime(attempt.submittedAt)}\n`;
            }
            output += "\n";
          });
          output += "-----------------------------\n";
        });

        return output;
      };

      const sendTranscriptOnNext = async () => {
        const ctx = getStudentContext();
        fullTranscript = buildFullTranscript();
        window.RPLFullTranscript = fullTranscript;
        const isLastQuestion = currentIndex + 1 >= questions.length;
        const currentQuestionValue = isLastQuestion ? "XXX" : String(currentIndex + 2);
        const payload = {
          FullName: ctx.fullName,
          ContactID: String(ctx.contactId),
          GivenName: ctx.givenName,
          FullTranscript: fullTranscript,
          CurrentQuestion: currentQuestionValue,
        };
        logAssessmentDebug("Transcript webhook", "Sending payload");
        const url =
          "https://default63871d3cd05d49fa86b6420054699f.b4.environment.api.powerplatform.com:443/powerautomate/automations/direct/workflows/903538467bfb426fb4b074ef9cc3caa4/triggers/manual/paths/invoke?api-version=1&sp=%2Ftriggers%2Fmanual%2Frun&sv=1.0&sig=H7BkpCmAeGTUqrl4NPh94_bK4-3hX5r82Xh-sbwnWG4";

        try {
          const response = await fetch(url, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          logDebugDetail("Transcript HTTP status", `${response.status} ${response.statusText}`);
          logAssessmentDebug("Transcript webhook", `${response.status} ${response.statusText}`);
          const text = await response.text();
          if (text) {
            logDebugDetail("Transcript response", text);
            logAssessmentDebug("Transcript response", text);
          }
          if (!response.ok) {
            throw new Error(`Transcript webhook failed (${response.status}) ${response.statusText}`.trim());
          }
          return true;
        } catch (error) {
          logDebugDetail("Transcript error", error?.message || String(error));
          logAssessmentDebug("Transcript error", error?.message || String(error));
          setStatus(error?.message || "Transcript webhook failed.");
          return false;
        }
      };

      const updateCurrentQuestionFromWebhook = async () => {
        if (isNoTranscriptResponse(lastStudentContextResponseText)) {
          currentIndex = 0;
          return false;
        }
        try {
          await fetchCurrentQuestionFromWebhook();
          const titleValue = typeof lastQuestionResponseText === "string"
            ? lastQuestionResponseText
            : String(lastQuestionResponseText || "");
          const titleMatchIndex = findQuestionIndexByTitle(titleValue);
          if (titleMatchIndex !== null) {
            currentIndex = titleMatchIndex;
            return true;
          }
          const numberText = extractQuestionNumberFromText(titleValue || "1");
          const numberMatchIndex = findQuestionIndexByTitleNumber(numberText || "1");
          if (numberMatchIndex !== null) {
            currentIndex = numberMatchIndex;
            return true;
          }
          currentIndex = 0;
          return false;
        } catch (error) {
          logDebugDetail("Current question error", error?.message || String(error));
          currentIndex = 0;
          return false;
        }
      };

      // const updateModeLabel = () => {
      //   if (!modeLabelEl) return;
      //   modeLabelEl.textContent = aiMode === "router" ? "RPL Router" : "RPL Base";
      // };

      const logDebug = (message) => {
        const timestamp = new Date().toLocaleTimeString();
        if (debugLogEl) {
          debugLogEl.textContent = `[${timestamp}] ${message}\n` + debugLogEl.textContent;
        }
        if (initDebugLogEl) {
          initDebugLogEl.textContent = `[${timestamp}] ${message}\n` + initDebugLogEl.textContent;
        }
      };

      const logDebugDetail = (label, detail) => {
        try {
          const formatted =
            typeof detail === "string"
              ? detail
              : JSON.stringify(detail, null, 2);
          logDebug(`${label}: ${formatted}`);
        } catch (err) {
          logDebug(`${label}: ${String(detail)}`);
        }
      };

      const logAssessmentDebug = (label, detail) => {
        if (!assessmentDebugLogEl) return;
        const timestamp = new Date().toLocaleTimeString();
        const message = detail === undefined || detail === null ? label : `${label}: ${detail}`;
        if (assessmentDebugLogEl.textContent === "Waiting for activity…") {
          assessmentDebugLogEl.textContent = "";
        }
        assessmentDebugLogEl.textContent = `[${timestamp}] ${message}\n` + assessmentDebugLogEl.textContent;
      };

      const loadPromptTemplates = async () => {
        try {
          const response = await fetch(PROMPTS_URL, { cache: "no-store" });
          if (!response.ok) {
            throw new Error(`Prompt load failed (${response.status})`);
          }
          const json = await response.json();
          promptTemplates = json;
          logDebugDetail("Prompts loaded", Object.keys(json || {}));
        } catch (err) {
          logDebugDetail("Prompt load error", err?.message || String(err));
          promptTemplates = null;
        }
      };

      const getWelcomeBodyText = (rawText) => {
        if (!rawText) return "";
        const text = String(rawText).trim();
        if (!text) return "";
        if (!/^[\[{]/.test(text)) return text;
        try {
          const json = JSON.parse(text);
          if (typeof json?.body === "string") return json.body;
          if (typeof json?.result === "string") return json.result;
          if (typeof json?.message === "string") return json.message;
          return text;
        } catch {
          return text;
        }
      };

      const updateWelcomeMessage = (responseText) => {
        const ctx = getStudentContext();
        const bodyText = getWelcomeBodyText(responseText);
        const normalized = bodyText.toLowerCase();
        const questionMatch = bodyText.match(/\b(\d{1,3})\b/);
        const questionNumber = questionMatch ? questionMatch[1] : "xxx";

        if (normalized.includes("new user")) {
          welcomeMode = "new";
          if (welcomeTitleEl) {
            welcomeTitleEl.textContent = `Hello ${ctx.fullName} and welcome to your RPL Assessment`;
          }
          if (welcomeBodyEl) {
            welcomeBodyEl.innerHTML = "";
          }
          if (welcomeContinueBtn) {
            welcomeContinueBtn.textContent = "Start Assessment";
          }
          return;
        }

        if (normalized.includes("user exists")) {
          welcomeMode = "existing";
          if (welcomeTitleEl) {
            welcomeTitleEl.textContent = `Hello ${ctx.fullName} and welcome back to your RPL Assessment`;
          }
          if (welcomeBodyEl) {
            welcomeBodyEl.innerHTML = "<p>Initialising…</p>";
          }
          if (welcomeContinueBtn) {
            welcomeContinueBtn.textContent = "RESUME";
          }
          return;
        }

        if (welcomeTitleEl) {
          welcomeTitleEl.textContent = "Welcome to the AAMC RPL Quiz";
        }
        if (welcomeBodyEl) {
          welcomeBodyEl.innerHTML = "";
        }
        if (welcomeContinueBtn) {
          welcomeContinueBtn.textContent = "Continue";
        }
        welcomeMode = "new";
      };

      const loadResumeWebhook = async () => {
        const ctx = getStudentContext();
        const payload = {
          FullName: ctx.fullName,
          ContactID: String(ctx.contactId),
          GivenName: ctx.givenName,
        };
        const url =
          "https://default63871d3cd05d49fa86b6420054699f.b4.environment.api.powerplatform.com:443/powerautomate/automations/direct/workflows/e227ea1f254a4fc885e0a6cbbed2a9ea/triggers/manual/paths/invoke?api-version=1&sp=%2Ftriggers%2Fmanual%2Frun&sv=1.0&sig=9wpXy_WL_FQZhqDZ18f2e6SwLneEIGN1QlGMMY7HnaI";
        logWelcomeDebug("Resume webhook", "Sending payload");
        try {
          const response = await fetch(url, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          logWelcomeDebug("Resume webhook", `${response.status} ${response.statusText}`);
          const text = await response.text();
          logWelcomeDebug("Resume response", text || "(empty)");
          if (!text) return null;
          let parsed = null;
          try {
            parsed = JSON.parse(text);
          } catch (err) {
            logWelcomeDebug("Resume parse error", err?.message || String(err));
            return null;
          }
          setWelcomeResumeData(parsed);
          if (welcomeBodyEl && resumeCurrentQuestionNumber) {
            welcomeBodyEl.innerHTML = `
              <p>It looks like you had already started this assessment and were on question ${resumeCurrentQuestionNumber}.</p>
              <p>Press the RESUME button to continue.</p>
            `;
          }
          return parsed;
        } catch (err) {
          logWelcomeDebug("Resume error", err?.message || String(err));
          return null;
        }
      };

      const loadWelcomeWebhook = async () => {
        logWelcomeDebug("Welcome webhook", "Calling welcome webhook…");
        if (welcomeTitleEl) {
          welcomeTitleEl.textContent = "Welcome to the AAMC RPL Quiz";
        }
        if (welcomeBodyEl) {
          welcomeBodyEl.innerHTML = "<p>Initialising…</p>";
        }
        if (welcomeContinueBtn) {
          welcomeContinueBtn.disabled = true;
        }
        const url =
          "https://default63871d3cd05d49fa86b6420054699f.b4.environment.api.powerplatform.com:443/powerautomate/automations/direct/workflows/9a8d98d38d584b44bb47066b652aa24d/triggers/manual/paths/invoke?api-version=1&sp=%2Ftriggers%2Fmanual%2Frun&sv=1.0&sig=Ion44zyKyWxVDVJYUfe9iJPVM-0G5ZLEZ6LRQEvrvWQ";
        try {
          const ctx = getStudentContext();
          const payload = {
            FullName: ctx.fullName,
            ContactID: String(ctx.contactId),
            GivenName: ctx.givenName,
          };
          const response = await fetch(url, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          logWelcomeDebug("Welcome webhook", `HTTP ${response.status} ${response.statusText}`);
          const text = await response.text();
          logWelcomeDebug("Welcome response", text || "(empty)");
          updateWelcomeMessage(text || "");
          if (text && text.toLowerCase().includes("user exists")) {
            resumeLoadPromise = loadResumeWebhook();
            await resumeLoadPromise;
          }
        } catch (err) {
          logWelcomeDebug("Welcome error", err?.message || String(err));
          updateWelcomeMessage("");
        } finally {
          if (welcomeContinueBtn) {
            welcomeContinueBtn.disabled = false;
          }
        }
      };

      const sendStudentContextOnLoad = async () => {
        /*
        const ctx = getStudentContext();
        if (responseBtn) responseBtn.disabled = true;
        if (questionBtn) questionBtn.disabled = true;
        const payload = {
          FullName: ctx.fullName,
          ContactID: String(ctx.contactId),
          GivenName: ctx.givenName,
        };
        const url =
          "https://default63871d3cd05d49fa86b6420054699f.b4.environment.api.powerplatform.com:443/powerautomate/automations/direct/workflows/d39da5be329d41849dd8148dadc64016/triggers/manual/paths/invoke?api-version=1&sp=%2Ftriggers%2Fmanual%2Frun&sv=1.0&sig=cJzfjCDuTI3kVJNFpiiZT2S47B8zS5XvDwTBIQRX6XE";

        logDebug("Sending student context on load");
        logDebugDetail("Student context payload", payload);

        try {
          const response = await fetch(url, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          logDebugDetail("Student context HTTP status", `${response.status} ${response.statusText}`);
          const rawText = await response.text();
          lastStudentContextResponseText = rawText || "";
          logDebugDetail("Student context response", rawText || "(empty)");
          if (responseBtn) responseBtn.disabled = false;
          if (questionBtn) questionBtn.disabled = false;
        } catch (error) {
          logDebugDetail("Student context error", error?.message || String(error));
          if (responseBtn) responseBtn.disabled = false;
          if (questionBtn) questionBtn.disabled = false;
        }
        */
      };

      const finishInitialisation = () => {
        if (initScreenEl) initScreenEl.classList.add("hidden");
        if (appShellEl) appShellEl.classList.remove("hidden");
      };

      const updateDictationUi = (stateText) => {
        if (dictationStatusEl) {
          dictationStatusEl.textContent = stateText;
        }
        if (dictateBtn) {
          dictateBtn.textContent = isDictating ? "Stop Transcription" : "Start Transcription";
          dictateBtn.disabled = isUiLocked || hintOpen;
        }
        if (playbackBtn) {
          playbackBtn.disabled = playbackLocked || isUiLocked || hintOpen || !lastPlaybackRecording?.blob;
        }
        if (playbackWidgetEl) {
          playbackWidgetEl.classList.toggle("disabled", !lastPlaybackRecording?.blob);
        }
        updatePlaybackButton();
      };

      const getQuestionHint = (question) => {
        if (!question || typeof question !== "object") return "";
        return (
          question.Hints ||
          question.hint ||
          question.field_6 ||
          question.field_4 ||
          question.field_7 ||
          ""
        );
      };

      const updateEvaluateButtonState = () => {
        if (!evaluateBtn) return;
        const answerText = answerInputEl?.value?.trim() || "";
        if (attemptLocked || isUiLocked || hintOpen) {
          evaluateBtn.disabled = true;
          return;
        }
        if (currentAttempts >= MAX_ATTEMPTS) {
          evaluateBtn.disabled = true;
          return;
        }
        evaluateBtn.disabled = !answerText;
      };

      const setAttemptLockState = (locked) => {
        attemptLocked = locked;
        if (answerInputEl) {
          answerInputEl.disabled = locked;
        }
        if (answerWrapEl) {
          answerWrapEl.classList.toggle("is-locked", locked);
        }
        if (locked) {
          attemptLockStates = new Map();
          getAllButtons().forEach((button) => {
            attemptLockStates.set(button, button.disabled);
            if (button !== nextBtn) {
              button.disabled = true;
            }
          });
          if (nextBtn) nextBtn.disabled = false;
          return;
        }
        if (attemptLockStates) {
          attemptLockStates.forEach((wasDisabled, button) => {
            if (button && button.isConnected) {
              button.disabled = wasDisabled;
            }
          });
          attemptLockStates = null;
        }
        updateEvaluateButtonState();
      };

      const getAllButtons = () => Array.from(document.querySelectorAll("button"));

      const setButtonsDisabled = (disabled, allowList = []) => {
        const allowSet = new Set(allowList);
        if (disabled) {
          lockedButtonStates = new Map();
          getAllButtons().forEach((button) => {
            lockedButtonStates.set(button, button.disabled);
            if (!allowSet.has(button)) {
              button.disabled = true;
            }
          });
          return;
        }
        if (lockedButtonStates) {
          lockedButtonStates.forEach((wasDisabled, button) => {
            if (button && button.isConnected) {
              button.disabled = wasDisabled;
            }
          });
          lockedButtonStates = null;
        }
      };

      const setUiLockedState = (locked) => {
        isUiLocked = locked;
        if (locked) {
          setButtonsDisabled(true, []);
        } else {
          setButtonsDisabled(false);
          updateDictationUi(dictationStatusEl?.textContent || "Dictation idle.");
          updateEvaluateButtonState();
          if (currentAttempts > 0 && nextBtn) {
            nextBtn.disabled = false;
          }
          if (attemptLocked) {
            setAttemptLockState(true);
          }
        }
      };

      const openHint = () => {
        if (!hintOverlayEl || !hintBodyEl) return;
        const question = questions[currentIndex] || {};
        const hintText = getQuestionHint(question) || "No hint available for this question.";
        hintBodyEl.textContent = hintText;
        hintOverlayEl.classList.remove("hidden");
        hintOpen = true;
        setButtonsDisabled(true, [hintCloseBtn]);
      };

      const closeHint = () => {
        if (!hintOverlayEl) return;
        hintOverlayEl.classList.add("hidden");
        hintOpen = false;
        setButtonsDisabled(false);
        updateDictationUi(dictationStatusEl?.textContent || "Dictation idle.");
      };

      const formatPlaybackTime = (value) => {
        if (!Number.isFinite(value) || value < 0) return "0:00";
        const total = Math.floor(value);
        const minutes = Math.floor(total / 60);
        const seconds = String(total % 60).padStart(2, "0");
        return `${minutes}:${seconds}`;
      };

      const applyTemplate = (template, data) => {
        if (!template) return "";
        return template.replace(/\{\{(\w+)\}\}/g, (_match, key) => {
          const value = data[key];
          return value === undefined || value === null ? "" : String(value);
        });
      };

      const updatePlaybackUi = (current, duration) => {
        const safeDuration = Number.isFinite(duration) && duration > 0 ? duration : 0;
        const safeCurrent = Number.isFinite(current) && current >= 0 ? current : 0;
        const ratio = safeDuration ? Math.min(1, safeCurrent / safeDuration) : 0;
        const percent = `${(ratio * 100).toFixed(2)}%`;
        if (playbackFillEl) playbackFillEl.style.width = percent;
        if (playbackIndicatorEl) playbackIndicatorEl.style.left = percent;
        if (playbackDotEl) playbackDotEl.style.left = percent;
        if (playbackTimeEl) {
          const durationLabel = safeDuration ? formatPlaybackTime(safeDuration) : "0:00";
          playbackTimeEl.textContent = `${formatPlaybackTime(safeCurrent)} / ${durationLabel}`;
        }
      };

      const updatePlaybackButton = () => {
        if (!playbackBtn) return;
        playbackBtn.textContent = playbackIsPlaying ? "Stop" : "Playback";
      };

      const setMeterState = (meterEl, isActive) => {
        if (!meterEl) return;
        meterEl.classList.toggle("active", isActive);
        meterEl.classList.toggle("inactive", !isActive);
      };

      const updateMeterFromAnalyser = (analyser, fillEl) => {
        if (!analyser || !fillEl) return 0;
        const bufferLength = analyser.fftSize;
        const data = new Uint8Array(bufferLength);
        analyser.getByteTimeDomainData(data);
        let sumSquares = 0;
        for (let i = 0; i < bufferLength; i += 1) {
          const normalized = (data[i] - 128) / 128;
          sumSquares += normalized * normalized;
        }
        const rms = Math.sqrt(sumSquares / bufferLength);
        const level = Math.min(1, rms * 2.5);
        fillEl.style.width = `${(level * 100).toFixed(1)}%`;
        return level;
      };

      const stopDictationMeter = () => {
        if (dictationMeterRaf) {
          cancelAnimationFrame(dictationMeterRaf);
          dictationMeterRaf = null;
        }
        if (dictationMeterFillEl) dictationMeterFillEl.style.width = "0%";
        setMeterState(dictationMeterEl, false);
        dictationAnalyser = null;
      };

      const startDictationMeter = () => {
        if (!audioCtx || !micSourceNode) return;
        dictationAnalyser = audioCtx.createAnalyser();
        dictationAnalyser.fftSize = 1024;
        try {
          micSourceNode.connect(dictationAnalyser);
        } catch {}
        setMeterState(dictationMeterEl, true);
        const tick = () => {
          updateMeterFromAnalyser(dictationAnalyser, dictationMeterFillEl);
          dictationMeterRaf = requestAnimationFrame(tick);
        };
        tick();
      };

      const stopPlaybackMeter = () => {
        if (playbackMeterRaf) {
          cancelAnimationFrame(playbackMeterRaf);
          playbackMeterRaf = null;
        }
        if (playbackMeterFillEl) playbackMeterFillEl.style.width = "0%";
        setMeterState(playbackMeterEl, false);
        playbackAnalyser = null;
      };

      const playStartTone = () => {
        if (!audioCtx) return;
        try {
          if (audioCtx.state === "suspended") {
            audioCtx.resume().catch(() => {});
          }
          const oscillator = audioCtx.createOscillator();
          const gainNode = audioCtx.createGain();
          oscillator.type = "sine";
          oscillator.frequency.value = 880;
          gainNode.gain.value = 0.0001;
          oscillator.connect(gainNode);
          gainNode.connect(audioCtx.destination);
          const now = audioCtx.currentTime;
          gainNode.gain.exponentialRampToValueAtTime(0.08, now + 0.01);
          gainNode.gain.exponentialRampToValueAtTime(0.0001, now + 0.18);
          oscillator.start(now);
          oscillator.stop(now + 0.2);
        } catch {}
      };

      const startPlaybackMeter = () => {
        if (!playbackAudio) return;
        if (!playbackAudioCtx) {
          playbackAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (playbackAudioCtx.state === "suspended") {
          playbackAudioCtx.resume().catch(() => {});
        }
        try {
          playbackAnalyser = playbackAudioCtx.createAnalyser();
          playbackAnalyser.fftSize = 1024;
          const sourceNode = playbackAudioCtx.createMediaElementSource(playbackAudio);
          sourceNode.connect(playbackAnalyser);
          playbackAnalyser.connect(playbackAudioCtx.destination);
        } catch {
          return;
        }
        setMeterState(playbackMeterEl, true);
        const tick = () => {
          updateMeterFromAnalyser(playbackAnalyser, playbackMeterFillEl);
          playbackMeterRaf = requestAnimationFrame(tick);
        };
        tick();
      };

      const stopPlayback = (options = {}) => {
        const { reset = true } = options;
        if (playbackAudio) {
          try { playbackAudio.pause(); } catch {}
          if (reset) {
            try { playbackAudio.currentTime = 0; } catch {}
          }
        }
        playbackIsPlaying = false;
        updatePlaybackButton();
        stopPlaybackMeter();
        if (reset) {
          updatePlaybackUi(0, lastPlaybackDuration);
        }
      };

      const startPlayback = () => {
        if (!lastPlaybackRecording?.blob) return;
        if (!lastPlaybackUrl) {
          lastPlaybackUrl = URL.createObjectURL(lastPlaybackRecording.blob);
        }
        if (playbackAudio) {
          try { playbackAudio.pause(); } catch {}
        }
        playbackAudio = new Audio(lastPlaybackUrl);
        playbackAudio.onloadedmetadata = () => {
          lastPlaybackDuration = playbackAudio.duration || 0;
          updatePlaybackUi(0, lastPlaybackDuration);
        };
        playbackAudio.ontimeupdate = () => {
          const duration = Number.isFinite(playbackAudio.duration) && playbackAudio.duration > 0
            ? playbackAudio.duration
            : lastPlaybackDuration || 0;
          if (duration && duration !== lastPlaybackDuration) {
            lastPlaybackDuration = duration;
          }
          updatePlaybackUi(playbackAudio.currentTime || 0, duration);
        };
        playbackAudio.onended = () => {
          stopPlayback({ reset: true });
        };
        playbackAudio.onerror = () => {
          stopPlayback({ reset: true });
          setStatus("Unable to play recording.");
        };
        playbackAudio.play()
          .then(() => {
            playbackIsPlaying = true;
            updatePlaybackButton();
            startPlaybackMeter();
          })
          .catch((err) => {
            stopPlayback({ reset: true });
            setStatus(err?.message || "Unable to play recording.");
          });
      };

      const blobToBase64 = (blob) => new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => {
          const result = reader.result;
          if (typeof result === "string") {
            const commaIndex = result.indexOf(",");
            resolve(commaIndex >= 0 ? result.slice(commaIndex + 1) : result);
          } else {
            reject(new Error("Unable to convert blob to base64."));
          }
        };
        reader.onerror = () => reject(reader.error || new Error("Unable to read blob."));
        reader.readAsDataURL(blob);
      });

      const startMediaRecorder = (stream) => {
        if (!stream || typeof MediaRecorder === "undefined") return;
        recordedChunks = [];
        lastResponseRecording = null;
        lastPlaybackRecording = null;
        stopPlayback({ reset: true });
        stopPlaybackMeter();
        stopDictationMeter();
        if (playbackBtn) playbackBtn.disabled = true;
        if (playbackWidgetEl) playbackWidgetEl.classList.add("disabled");
        if (lastPlaybackUrl) {
          URL.revokeObjectURL(lastPlaybackUrl);
          lastPlaybackUrl = "";
        }
        lastPlaybackDuration = 0;
        playbackLocked = false;
        updatePlaybackUi(0, 0);
        try {
          mediaRecorder = new MediaRecorder(stream);
        } catch (err) {
          logDebug("MediaRecorder unavailable", err?.message || String(err));
          mediaRecorder = null;
          return;
        }
        mediaRecorder.ondataavailable = (event) => {
          if (event.data && event.data.size) {
            recordedChunks.push(event.data);
          }
        };
        mediaRecorder.onstop = () => {
          if (!recordedChunks.length) return;
          const blob = new Blob(recordedChunks, { type: mediaRecorder?.mimeType || "audio/webm" });
          lastResponseRecording = {
            blob,
            contentType: blob.type || "audio/webm",
          };
          lastPlaybackRecording = lastResponseRecording;
          playbackLocked = false;
          if (playbackBtn) playbackBtn.disabled = false;
          if (playbackWidgetEl) playbackWidgetEl.classList.remove("disabled");
          lastPlaybackDuration = 0;
          updatePlaybackUi(0, 0);
          updateDictationUi(dictationStatusEl?.textContent || "Dictation idle.");
          recordedChunks = [];
        };
        try {
          mediaRecorder.start();
        } catch (err) {
          logDebug("MediaRecorder start failed", err?.message || String(err));
        }
      };

      const stopMediaRecorder = () => {
        if (!mediaRecorder) return;
        if (mediaRecorder.state !== "inactive") {
          try {
            mediaRecorder.stop();
          } catch (err) {
            logDebug("MediaRecorder stop failed", err?.message || String(err));
          }
        }
      };

      const sendRecordingOnEvaluate = async (attemptNumber, questionNumber) => {
        if (!lastResponseRecording?.blob) return;
        const ctx = getStudentContext();
        const givenName = ctx.givenName;
        const nameValue = fullName || ctx.fullName;
        const contactValue = String(ctx.contactId);
        const base64Data = await blobToBase64(lastResponseRecording.blob);
        const payload = {
          FullName: nameValue,
          GivenName: givenName,
          ContactID: contactValue,
          Recordings: [
            {
              FileName: `${nameValue} - ${contactValue} - ${questionNumber} - ${attemptNumber}`,
              Label: `Question ${questionNumber} Attempt ${attemptNumber}`,
              ContentType: lastResponseRecording.contentType || "audio/webm",
              Base64Data: base64Data,
            }
          ]
        };
        const url =
          "https://default63871d3cd05d49fa86b6420054699f.b4.environment.api.powerplatform.com:443/powerautomate/automations/direct/workflows/e4f5525ffa66441d927fd17bbaf5bd03/triggers/manual/paths/invoke?api-version=1&sp=%2Ftriggers%2Fmanual%2Frun&sv=1.0&sig=0h2Wg4ORGlkmrTtS7fw09cv8m4MTH74l68qwSmw3t4s";
        try {
          const response = await fetch(url, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          logDebugDetail("Recording HTTP status", `${response.status} ${response.statusText}`);
          const text = await response.text();
          if (text) {
            logDebugDetail("Recording response", text);
          }
        } catch (error) {
          logDebugDetail("Recording error", error?.message || String(error));
        } finally {
          lastResponseRecording = null;
        }
      };

      const fetchAzureSpeechToken = async () => {
        const now = Date.now();
        if (speechTokenInfo.token && speechTokenInfo.region && speechTokenInfo.expiresAt - 60000 > now) {
          return speechTokenInfo;
        }
        const response = await fetch("/api/speech/token", { method: "POST" });
        if (!response.ok) {
          const text = await response.text().catch(() => "");
          throw new Error(`Token request failed (${response.status}) ${text}`.trim());
        }
        const payload = await response.json().catch(() => ({}));
        const token = payload.token || payload.accessToken || payload.authToken;
        const region = payload.region || payload.serviceRegion;
        if (!token || !region) {
          throw new Error("Speech token response missing token or region.");
        }
        const expiresIn = typeof payload.expiresIn === "number" ? payload.expiresIn : 540;
        speechTokenInfo = {
          token,
          region,
          expiresAt: now + Math.max(300, expiresIn) * 1000,
        };
        logDebug("Fetched Azure speech token", { region, expiresIn });
        return speechTokenInfo;
      };

      const downsampleTo16BitPCM = (buffer, inputSampleRate, outputSampleRate) => {
        if (!buffer || !buffer.length) return null;
        const ratio = inputSampleRate / outputSampleRate;
        if (ratio <= 1) outputSampleRate = inputSampleRate;
        const newLength = Math.floor(buffer.length / Math.max(1, ratio));
        const pcmBuffer = new ArrayBuffer(newLength * 2);
        const view = new DataView(pcmBuffer);
        let offsetResult = 0;
        let offsetBuffer = 0;
        while (offsetResult < newLength) {
          const nextOffsetBuffer = Math.min(buffer.length, Math.round((offsetResult + 1) * ratio));
          let sum = 0;
          let count = 0;
          for (let i = offsetBuffer; i < nextOffsetBuffer; i += 1) {
            sum += buffer[i];
            count += 1;
          }
          const sample = count > 0 ? sum / count : 0;
          const clamped = Math.max(-1, Math.min(1, sample));
          view.setInt16(offsetResult * 2, clamped < 0 ? clamped * 0x8000 : clamped * 0x7fff, true);
          offsetResult += 1;
          offsetBuffer = nextOffsetBuffer;
        }
        return pcmBuffer;
      };

      const attachAzureTap = (audioContext, sourceNode) => {
        if (!audioContext || !sourceNode) return;
        detachAzureTap();
        speechTapGain = audioContext.createGain();
        speechTapGain.gain.value = 1;
        sourceNode.connect(speechTapGain);

        speechTapNode = audioContext.createScriptProcessor(4096, 1, 1);
        speechTapGain.connect(speechTapNode);

        speechSilentGain = audioContext.createGain();
        speechSilentGain.gain.value = 0;
        speechTapNode.connect(speechSilentGain);
        speechSilentGain.connect(audioContext.destination);

        speechTapNode.onaudioprocess = (event) => {
          if (!speechPushStream) return;
          const input = event.inputBuffer.getChannelData(0);
          const pcm = downsampleTo16BitPCM(input, event.inputBuffer.sampleRate, 16000);
          if (!pcm) return;
          try {
            speechPushStream.write(pcm);
          } catch (err) {
            logDebug("Azure speech push failed", err instanceof Error ? err.message : err);
          }
        };
      };

      const detachAzureTap = () => {
        if (speechTapNode) {
          try { speechTapNode.disconnect(); } catch {}
          speechTapNode.onaudioprocess = null;
          speechTapNode = null;
        }
        if (speechTapGain) {
          try { speechTapGain.disconnect(); } catch {}
          speechTapGain = null;
        }
        if (speechSilentGain) {
          try { speechSilentGain.disconnect(); } catch {}
          speechSilentGain = null;
        }
      };

      const startAzureRecognition = async (audioContext, sourceNode) => {
        if (!window.SpeechSDK) {
          throw new Error("Azure Speech SDK not available");
        }
        const SpeechSDK = window.SpeechSDK;
        const { token, region } = await fetchAzureSpeechToken();
        const language = "en-AU";

        const format = SpeechSDK.AudioStreamFormat.getWaveFormatPCM(16000, 16, 1);
        speechPushStream = SpeechSDK.AudioInputStream.createPushStream(format);
        const audioConfig = SpeechSDK.AudioConfig.fromStreamInput(speechPushStream);
        const speechConfig = SpeechSDK.SpeechConfig.fromAuthorizationToken(token, region);
        speechConfig.speechRecognitionLanguage = language;

        speechRecognizer = new SpeechSDK.SpeechRecognizer(speechConfig, audioConfig);
        attachAzureTap(audioContext, sourceNode);

        speechRecognizer.recognizing = (_sender, event) => {
          if (!event?.result?.text || manualOverride) return;
          const partial = event.result.text.trim();
          if (!partial) return;
          answerInputEl.value = `${finalTranscript}${partial}`.trim();
        };

        speechRecognizer.recognized = (_sender, event) => {
          if (!event?.result) return;
          if (event.result.reason === SpeechSDK.ResultReason.RecognizedSpeech) {
            const transcript = event.result.text?.trim();
            if (!transcript || manualOverride) return;
            finalTranscript += `${transcript} `;
            answerInputEl.value = `${finalTranscript}`.trim();
            updateEvaluateButtonState();
            logDebug("Azure speech final segment", {
              transcript: transcript.length > 160 ? `${transcript.slice(0, 160)}…` : transcript
            });
          }
        };

        speechRecognizer.canceled = (_sender, event) => {
          const reason = event?.reason;
          const details = event?.errorDetails || reason || "unknown";
          logDebug("Azure speech cancelled", { details });
          updateDictationUi("Dictation error: Azure speech cancelled");
        };

        speechRecognizer.sessionStarted = () => {
          isDictating = true;
          manualOverride = false;
          updateDictationUi("Listening...");
          startDictationMeter();
          logDebug("Dictation started.");
        };

        speechRecognizer.sessionStopped = () => {
          isDictating = false;
          updateDictationUi("Dictation stopped.");
          stopDictationMeter();
          logDebug("Dictation stopped.");
        };

        return new Promise((resolve, reject) => {
          speechRecognizer.startContinuousRecognitionAsync(
            () => {
              logDebug("Azure speech recognizer started", { language, region });
              resolve();
            },
            (error) => {
              const message = error instanceof Error ? error.message : String(error || "Unknown error");
              logDebug("Azure speech recognizer start failed", message);
              updateDictationUi("Dictation error: Azure speech unavailable");
              stopAzureRecognition();
              reject(new Error(message));
            }
          );
        });
      };

      const stopAzureRecognition = () => {
        const recognizer = speechRecognizer;
        speechRecognizer = null;
        if (speechPushStream) {
          try { speechPushStream.close(); } catch {}
          speechPushStream = null;
        }
        detachAzureTap();
        if (!recognizer) return;
        try {
          recognizer.stopContinuousRecognitionAsync(
            () => {
              logDebug("Azure speech recognizer stopped");
              try { recognizer.close?.(); } catch {}
            },
            (error) => {
              logDebug("Azure speech recognizer stop failed", error instanceof Error ? error.message : error);
              try { recognizer.close?.(); } catch {}
            }
          );
        } catch (err) {
          logDebug("Azure speech recognizer stop threw", err instanceof Error ? err.message : err);
          try { recognizer.close?.(); } catch {}
        }
      };

      const startDictation = () => {
        if (isDictating) return;
        if (!window.SpeechSDK) {
          updateDictationUi("Dictation not supported in this browser.");
          logDebug("Azure Speech SDK not available.");
          return;
        }
        finalTranscript = answerInputEl.value.trim();
        if (finalTranscript) {
          finalTranscript = `${finalTranscript} `;
        }
        const savedDeviceId = micSelectEl?.value || localStorage.getItem(MIC_STORAGE_KEY) || "";
        const constraints = savedDeviceId
          ? { audio: { deviceId: { exact: savedDeviceId } } }
          : { audio: true };
        navigator.mediaDevices
          .getUserMedia(constraints)
          .then((stream) => {
            micStream = stream;
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            micSourceNode = audioCtx.createMediaStreamSource(stream);
            playStartTone();
            startMediaRecorder(stream);
            return startAzureRecognition(audioCtx, micSourceNode);
          })
          .catch((err) => {
            updateDictationUi("Dictation error: microphone unavailable");
            stopDictationMeter();
            logDebug(`Dictation start failed: ${err?.message || String(err)}`);
          });
      };

      const stopDictation = () => {
        if (!isDictating && !speechRecognizer) return;
        try {
          stopMediaRecorder();
          stopAzureRecognition();
        } catch (err) {
          logDebug(`Dictation stop failed: ${err?.message || String(err)}`);
        }
        stopDictationMeter();
        if (micStream) {
          micStream.getTracks().forEach((track) => track.stop());
          micStream = null;
        }
        if (audioCtx) {
          try { audioCtx.close(); } catch {}
          audioCtx = null;
        }
        micSourceNode = null;
      };

      const parseListItems = (json) => {
        if (!json || typeof json.listitems !== "string") {
          return { items: [], error: "Response does not include listitems." };
        }
        try {
          const listItems = JSON.parse(json.listitems);
          if (!Array.isArray(listItems)) {
            return { items: [], error: "listitems is not an array." };
          }
          return { items: listItems, error: null };
        } catch (parseError) {
          return { items: [], error: parseError?.message || String(parseError) };
        }
      };

      const addChatEntry = (text, role) => {
        const entry = document.createElement("div");
        entry.className = `chatEntry ${role}`;
        entry.textContent = text;
        chatHistoryEl.appendChild(entry);
        chatHistoryEl.scrollTop = chatHistoryEl.scrollHeight;
        appendToTranscript(role === "user" ? "User" : "System", text);
      };

      const buildQuestionsTableHtml = (questionList) => {
        if (!Array.isArray(questionList) || !questionList.length) {
          return "<p>No questions available.</p>";
        }
        const allKeys = questionList.reduce((keys, question) => {
          if (!question || typeof question !== "object") return keys;
          Object.keys(question).forEach((key) => keys.add(key));
          return keys;
        }, new Set());

        const orderedKeys = Array.from(allKeys);
        if (!orderedKeys.length) return "<p>No question fields available.</p>";

        const escapeHtml = (value) => String(value)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/\"/g, "&quot;")
          .replace(/'/g, "&#39;");

        const headerRow = orderedKeys
          .map((key) => `<th>${escapeHtml(key)}</th>`)
          .join("");

        const bodyRows = questionList
          .map((question) => {
            const cells = orderedKeys
              .map((key) => {
                const value = question?.[key];
                const cellText =
                  value === null || value === undefined
                    ? ""
                    : typeof value === "object"
                      ? JSON.stringify(value)
                      : String(value);
                return `<td>${escapeHtml(cellText)}</td>`;
              })
              .join("");
            return `<tr>${cells}</tr>`;
          })
          .join("");

        return `
          <div style="font-family:Segoe UI, Tahoma, Geneva, Verdana, sans-serif; color:#0f172a;">
            <h2 style="margin:0 0 12px; font-size:18px;">Question Table</h2>
            <div style="overflow:auto; border:1px solid #e2e8f0; border-radius:10px;">
              <table style="border-collapse:collapse; width:100%; min-width:700px;">
                <thead>
                  <tr style="background:#f8fafc; text-align:left;">
                    ${headerRow}
                  </tr>
                </thead>
                <tbody>
                  ${bodyRows}
                </tbody>
              </table>
            </div>
            <style>
              th, td { border: 1px solid #cbd5f5; padding: 8px 10px; vertical-align: top; }
              th { font-weight: 700; font-size: 13px; }
              td { font-size: 12px; }
              tbody tr:nth-child(even) { background: #f9fbff; }
            </style>
          </div>
        `;
      };

      const renderQuestion = () => {
        const question = questions[currentIndex] || {};
        const total = questions.length;
        const number = currentIndex + 1;
        headerTitleEl.textContent = `Compliance - Question ${number} of ${total} - Attempt 1`;
        questionTextEl.textContent = question.field_5 || question.Title || "";
        answerInputEl.value = "";
        lastResponseRecording = null;
        lastPlaybackRecording = null;
        stopPlayback({ reset: true });
        if (playbackBtn) playbackBtn.disabled = true;
        if (playbackWidgetEl) playbackWidgetEl.classList.add("disabled");
        if (lastPlaybackUrl) {
          URL.revokeObjectURL(lastPlaybackUrl);
          lastPlaybackUrl = "";
        }
        lastPlaybackDuration = 0;
        updatePlaybackUi(0, 0);
        currentAttempts = 0;
        currentResponses = [];
        evaluateBtn.disabled = true;
        nextBtn.disabled = true;
        chatHistoryEl.textContent = "";
        setAttemptLockState(false);
        if (showHintBtn) showHintBtn.disabled = false;
        updateEvaluateButtonState();
      };

      const buildPrompt = (question, answers) => {
        const questionText = question.field_5 || question.Title || "";
        const objective = question.field_3 || "";
        const answerBlock = answers
          .map((response, index) => `Attempt ${index + 1}: ${response}`)
          .join("\n");
        const ctx = getStudentContext();
        const template = promptTemplates?.assessmentPrompt;
        if (template) {
          return applyTemplate(template, {
            FullName: fullName || ctx.fullName,
            GivenName: firstName || ctx.givenName || ctx.fullName,
            ContactID: ctx.contactId,
            Industry: industry || industryEl?.value?.trim() || "",
            JobTitle: jobTitle || jobTitleEl?.value?.trim() || "",
            QuestionText: questionText,
            Objective: objective,
            Answers: answerBlock,
          });
        }
        return `You are an expert in the Australian Financial industry and are acting as an assessor of ${fullName}'s responses to the question '${questionText}'. ${firstName} has provided multiple attempts. Use all attempts together to judge completeness without requiring repetition.\n\n${answerBlock}\n\nTake into account ${fullName} works in the ${industry} Industry as a ${jobTitle} and assess using the objective '${objective}' if they have demonstrated the required understanding, even if key terms, concepts, or regulations are implied rather than explicitly stated.\n\nProvide a concise overview to ${firstName} that follows these rules:\n\n1) If the responses together effectively answer the question and meet the intent of the Objective, do not ask for any further details. Acknowledge that the response is sufficient and tell them to move to the next question.\n\n2) If the responses together have not effectively answered the question or do not meet the Objective, do not give the answer. Only ask for the missing information that has not been covered yet. Advise ${firstName} to add more details by pressing the 'Start' button or typing in the Chat box below. Tell them that if they cannot add any more they can move to the next question.\n\n3) Do not say 'Hi' at the start of the response.`;
      };

      const buildFinalReviewPrompt = (reviewText) => {
        const industryValue = industry || industryEl?.value?.trim() || "";
        const ctx = getStudentContext();
        const template = promptTemplates?.finalReviewPrompt;
        if (template) {
          return applyTemplate(template, {
            FullName: fullName || ctx.fullName,
            GivenName: firstName || ctx.givenName || ctx.fullName,
            ContactID: ctx.contactId,
            Industry: industryValue || "Not stated in the Review",
            JobTitle: jobTitle || jobTitleEl?.value?.trim() || "",
            ReviewText: reviewText,
          });
        }
        return `You are an expert reviewer in Australia for the ${industryValue || "Not stated in the Review"} industry. Use Australian English and spelling.

SOURCE OF TRUTH
Use ONLY the content inside the REVIEW block below. Do not use outside knowledge.
If a detail is missing, write exactly: Not stated in the Review.

STATUS RULE
- Satisfactory = every question is ultimately satisfactory (including after follow-ups recorded in the source).
- Discussion Required = at least one question remains unsatisfactory or unanswered in the final state.

OUTPUT RULES
- Produce valid HTML only (no code fences/CSS/JS).
- Follow the structure EXACTLY as below; do not add other sections.
- Keep tone factual and neutral.
- Do NOT include recommendations, next steps, guidance, or action items.

CONDITIONALS (do NOT render these lines in the output; they are just instructions)
- If there are NO initially-unsatisfactory questions, in the “Questions Where the Student Did Not Give a Satisfactory Answer” section output ONLY:
  “All questions were ultimately answered satisfactorily.” and do NOT include any <article> blocks.
- If there ARE any initially-unsatisfactory questions, output one <article> block per such question (as shown), then proceed to the satisfactory list.

HTML STRUCTURE (fill placeholders ONLY from the REVIEW; comments below are invisible in browsers)

<u><strong>RPL Assessment Review Report</strong></u>

<section>
  <p><strong>Name:</strong>  Student Name </p>
  <p><strong>Industry:</strong>  Industry </p>
  <p><strong>Job Title:</strong>  Job Title </p>
</section>

<u><strong>Executive Summary — [Satisfactory | Discussion Required]</strong></u>
<p>
  2–5 sentences stating this is an RPL assessment review; summarising what was
  evaluated at a high level (e.g., regulatory knowledge, ethics, client service,
  workload management, professional development) using Australian terminology;
  and giving a neutral overall appraisal consistent with the selected status.
  Only include details present in the REVIEW; if a required detail is missing,
  write: Not stated in the Review.
</p>

<u><strong>Questions Where the Student Did Not Give a Satisfactory Answer</strong></u>
<!-- If none: output only the next paragraph line; omit all <article> blocks. -->
<p>All questions were ultimately answered satisfactorily.</p>

<!-- If there were initially-unsatisfactory questions, DELETE the single line above
     and output one <article> block per question using this pattern: -->
<!--
<article>
  <u><strong>Question [#]: [Short question text]</strong></u>
  <p><strong>Why listed here:</strong> Initially required further detail before being deemed satisfactory, or remains unsatisfactory.</p>
  <p><strong>Student’s Initial Response:</strong> [Concise paraphrase of the student’s first answer]</p>
  <p><strong>AssessorBot Feedback:</strong> [Key feedback requesting additions/clarifications]</p>
  <p><strong>Student’s Follow-up Response:</strong> [Concise paraphrase of the follow-up; if none, write: Not stated in the Review]</p>
  <p><strong>AssessorBot Final Comment/Outcome:</strong> [Outcome summary; note whether the answer became satisfactory or still needs discussion]</p>
</article>
-->

<u><strong>Questions Where the Student Gave a Satisfactory Answer</strong></u>
<ul>
  <!-- List each question that was satisfactory in the final state -->
  <li><strong>Question [#]:</strong> [One-line description of what the student demonstrated or identified]</li>
</ul>

REVIEW
<<<BEGIN_REVIEW
${reviewText}
END_REVIEW>>>`;
      };

      const callTextModel = async (prompt, options = {}) => {
        const mode = options.mode || aiMode;
        const temperature = typeof options.temperature === "number" ? options.temperature : 0.2;
        const maxTokens = Number.isFinite(Number(options.max_tokens)) ? Number(options.max_tokens) : 300;
        logDebug("Calling /api/analysis/chat");
        logDebugDetail("AI mode", mode);
        logDebugDetail("Prompt length", prompt?.length ?? 0);
        const response = await fetch("/api/analysis/chat", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "x-rpl-mode": mode,
          },
          body: JSON.stringify({
            prompt,
            temperature,
            max_tokens: maxTokens,
          }),
        });

        logDebugDetail("HTTP status", `${response.status} ${response.statusText}`);
        logDebugDetail("Response headers", Object.fromEntries(response.headers.entries()));

        if (!response.ok) {
          const text = await response.text();
          logDebug(`AI error ${response.status}: ${response.statusText} ${text}`);
          throw new Error(`Azure OpenAI error: ${response.status} ${response.statusText} ${text}`);
        }

        const json = await response.json();
        logDebug("AI response received.");
        logDebugDetail("AI response JSON", json);
        const content = json?.content || json?.response || json?.text;
        if (typeof content === "string" && content.trim()) return content.trim();
        const raw = json?.raw || {};
        logDebugDetail("AI response raw", raw);
        const rawContent =
          raw?.choices?.[0]?.message?.content ||
          raw?.choices?.[0]?.text ||
          raw?.content ||
          raw?.response ||
          raw?.text;
        if (typeof rawContent === "string" && rawContent.trim()) return rawContent.trim();
        const messages = Array.isArray(json?.messages) ? json.messages : [];
        const last = messages.length ? messages[messages.length - 1] : null;
        const text = last?.text || last?.content || "";
        if (!text) throw new Error("No response content returned.");
        return String(text).trim();
      };

      const beginAssessmentFlow = async ({ skipValidation = false, skipCollect = false } = {}) => {
        const ctx = getStudentContext();
        fullName = fullNameEl ? fullNameEl.value.trim() : "";
        if (!fullName) {
          fullName = ctx.fullName || DEFAULT_FULL_NAME;
        }

        const industryValue = industryEl?.value?.trim() || industry || "";
        const jobValue = jobTitleEl?.value?.trim() || jobTitle || "";
        if (!skipValidation && (!industryValue || !jobValue)) {
          setStatus("Please complete all fields.");
          return;
        }

        if (lastPhotoDataUrl) {
          const photoWebhookUrl =
            "https://default63871d3cd05d49fa86b6420054699f.b4.environment.api.powerplatform.com:443/powerautomate/automations/direct/workflows/eed37019d13445dca3ed1328184834cd/triggers/manual/paths/invoke?api-version=1&sp=%2Ftriggers%2Fmanual%2Frun&sv=1.0&sig=5N4jQe1NiJqap973EL0-OkOSZOn4fiICPEMVBaqQEdY";
          try {
            const contentType = "image/jpeg";
            const base64Data = lastPhotoDataUrl.includes(",")
              ? lastPhotoDataUrl.split(",")[1]
              : lastPhotoDataUrl;
            const payload = {
              FullName: ctx.fullName,
              ContactID: String(ctx.contactId),
              FileName: `${ctx.fullName} - ${ctx.contactId} - Photo`,
              ContentType: contentType,
              Base64Data: base64Data,
            };
            await fetch(photoWebhookUrl, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload),
            });
          } catch (error) {
            setStatus(error?.message || String(error));
            return;
          }
        }

        industry = industryValue;
        jobTitle = jobValue;
        if (industryEl && industryValue) industryEl.value = industryValue;
        if (jobTitleEl && jobValue) jobTitleEl.value = jobValue;

        firstName = ctx.givenName || fullName.split(" ").filter(Boolean)[0] || fullName;
        assessmentStartAt = new Date();
        setStatus("Loading questions...");
        beginBtn.disabled = true;
        if (postWelcomeTitleEl) {
          postWelcomeTitleEl.textContent = "Assessment Page";
        }

        if (!skipCollect) {
          const collectWebhookUrl =
            "https://default63871d3cd05d49fa86b6420054699f.b4.environment.api.powerplatform.com:443/powerautomate/automations/direct/workflows/b4b86e7b16654f45bd2b7308c92d239f/triggers/manual/paths/invoke?api-version=1&sp=%2Ftriggers%2Fmanual%2Frun&sv=1.0&sig=HNr3uiZ_XRh7ZeY4Z0cU6rKdXCC6G1bprVZj7K7hff0";
          try {
            const payload = {
              FullName: ctx.fullName,
              ContactID: String(ctx.contactId),
              GivenName: ctx.givenName,
              Industry: industry,
              jobTitle: jobTitle,
            };
            await fetch(collectWebhookUrl, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload),
            });
          } catch (error) {
            setStatus(error?.message || String(error));
          }
        }

        try {
          const response = await fetch(questionsUrl, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
          });
          const json = await response.json();
          const { items, error } = parseListItems(json);
          if (error || !items.length) {
            throw new Error(error || "No questions returned.");
          }
          questions = items;
          if (tableBtn) tableBtn.disabled = false;
          setupCard.classList.add("hidden");
          quizCard.classList.remove("hidden");

          if (resumeTranscriptText) {
            applyTranscriptResume(resumeTranscriptText);
          }
          if (resumeCurrentQuestionNumber && Number.isFinite(resumeCurrentQuestionNumber)) {
            const targetIndex = Math.max(0, resumeCurrentQuestionNumber - 1);
            currentIndex = Math.min(targetIndex, Math.max(0, questions.length - 1));
          } else if (!skipValidation) {
            await updateCurrentQuestionFromWebhook();
          }

          if (currentIndex >= questions.length) {
            setCompletedState();
          } else {
            renderQuestion();
            setStatus("Ready.");
            if (progressRowEl) progressRowEl.classList.add("hidden");
          }
        } catch (err) {
          setStatus(err?.message || String(err));
          beginBtn.disabled = false;
        }
      };

      beginBtn.addEventListener("click", async () => {
        await beginAssessmentFlow({ skipValidation: false });
      });

      const startInitialisation = async ({ resume = false } = {}) => {
        if (initStatusEl) initStatusEl.textContent = "Initialising…";
        if (setupCard) setupCard.classList.toggle("hidden", resume);
        if (quizCard) quizCard.classList.add("hidden");
        if (progressRowEl) progressRowEl.classList.add("hidden");
        applyUrlStudentContext();
        updateStudentContextBanner();
        updateCollectGreeting();
        initFullTranscript();
        updateDebugVisibility();
        window.addEventListener("hashchange", updateDebugVisibility);
        await loadPromptTemplates();
        await sendStudentContextOnLoad();
        await populateMicrophones();
        if (!resume) {
          await populateCameras();
          await startCamera();
          setCollectStepsEnabled({ industry: false, jobTitle: false, begin: false });
        }
        if (initStatusEl) initStatusEl.textContent = "Ready.";
        finishInitialisation();
      };

      if (initScreenEl) initScreenEl.classList.add("hidden");
      if (appShellEl) appShellEl.classList.add("hidden");

      applyUrlStudentContext();
      updateCollectGreeting();
      setCollectStepsEnabled({ industry: false, jobTitle: false, begin: false });
      loadWelcomeWebhook();

      welcomeContinueBtn?.addEventListener("click", async () => {
        if (welcomeScreenEl) welcomeScreenEl.classList.add("hidden");
        if (postWelcomePageEl) postWelcomePageEl.classList.remove("hidden");
        if (postWelcomeTitleEl) {
          postWelcomeTitleEl.textContent =
            welcomeMode === "existing" ? "Assessment Page" : "Collect User Data";
        }
        if (initScreenEl) initScreenEl.classList.remove("hidden");
        if (appShellEl) appShellEl.classList.add("hidden");
        await startInitialisation({ resume: welcomeMode === "existing" });
        if (welcomeMode === "existing") {
          if (resumeLoadPromise) {
            await resumeLoadPromise;
          }
          await beginAssessmentFlow({ skipValidation: true, skipCollect: true });
        }
      });

      dictateBtn?.addEventListener("click", () => {
        if (isDictating) {
          stopDictation();
        } else {
          startDictation();
        }
      });
      takePhotoBtn?.addEventListener("click", () => {
        if (!cameraStream) {
          startCamera();
          return;
        }
        capturePhoto();
      });
      confirmIndustryBtn?.addEventListener("click", () => {
        if (!industryEl?.value?.trim()) {
          setStatus("Select an industry before confirming.");
          return;
        }
        setStatus("Industry confirmed.");
        setCollectStepsEnabled({ industry: true, jobTitle: true, begin: false });
      });
      confirmJobTitleBtn?.addEventListener("click", () => {
        if (!jobTitleEl?.value?.trim()) {
          setStatus("Enter a job title before confirming.");
          return;
        }
        setStatus("Job title confirmed.");
        setCollectStepsEnabled({ industry: true, jobTitle: true, begin: true });
      });
      cameraSelectEl?.addEventListener("change", () => {
        if (cameraStream) startCamera();
      });
      navigator?.mediaDevices?.addEventListener?.("devicechange", () => populateCameras());
      playbackBtn?.addEventListener("click", () => {
        if (!lastPlaybackRecording?.blob) {
          setStatus("No recording available for playback.");
          return;
        }
        if (playbackIsPlaying) {
          stopPlayback({ reset: true });
          return;
        }
        startPlayback();
      });
      micSelectEl?.addEventListener("change", (event) => {
        const value = event.target?.value || "";
        localStorage.setItem(MIC_STORAGE_KEY, value);
        setMicStatus("Microphone selection saved.");
      });
      navigator?.mediaDevices?.addEventListener?.("devicechange", () => populateMicrophones());

      showHintBtn?.addEventListener("click", () => openHint());
      hintCloseBtn?.addEventListener("click", () => closeHint());
      hintOverlayEl?.addEventListener("click", (event) => {
        if (event.target === hintOverlayEl) {
          closeHint();
        }
      });

      answerInputEl.addEventListener("input", () => {
        if (isDictating) {
          manualOverride = true;
          stopDictation();
        }
        updateEvaluateButtonState();
      });

      evaluateBtn.addEventListener("click", async () => {
        const answer = answerInputEl.value.trim();
        if (!answer) {
          setStatus("Please enter an answer before evaluating.");
          return;
        }
        if (currentAttempts >= MAX_ATTEMPTS) {
          setStatus("Maximum attempts reached. Please move to the next question.");
          evaluateBtn.disabled = true;
          nextBtn.disabled = false;
          return;
        }

        currentAttempts += 1;
        currentResponses.push(answer);
        const questionText = questions[currentIndex]?.field_5 || questions[currentIndex]?.Title || "";
        const attemptNumber = currentAttempts;
        const questionNumber = currentIndex + 1;
        const attemptRecord = {
          answer,
          submittedAt: new Date(),
          feedback: "",
        };
        addChatEntry(`Attempt ${currentAttempts}: ${answer}`, "user");
        setStatus(`Evaluating response (attempt ${currentAttempts} of ${MAX_ATTEMPTS})...`);
        evaluateBtn.disabled = true;
        playbackLocked = true;
        updateDictationUi(dictationStatusEl?.textContent || "Dictation idle.");
        setUiLockedState(true);

        try {
          await sendRecordingOnEvaluate(attemptNumber, questionNumber);
          const prompt = buildPrompt(questions[currentIndex], currentResponses);
          const feedback = await callTextModel(prompt);
          addChatEntry(feedback, "ai");
          attemptRecord.feedback = feedback;
          const entry = ensureTranscriptQuestion(currentIndex, questionText);
          entry.questionText = questionText;
          entry.attempts.push(attemptRecord);
          entry.summary = feedback;
          answerInputEl.value = "";
          updateEvaluateButtonState();
          nextBtn.disabled = false;
          if (currentAttempts >= MAX_ATTEMPTS) {
            evaluateBtn.disabled = true;
            setStatus("Feedback ready. Maximum attempts reached.");
            setAttemptLockState(true);
          } else {
            evaluateBtn.disabled = false;
            setStatus(`Feedback ready. You have ${MAX_ATTEMPTS - currentAttempts} attempt(s) left.`);
          }
        } catch (err) {
          addChatEntry(err?.message || String(err), "ai");
          setStatus("Evaluation failed.");
          evaluateBtn.disabled = false;
        } finally {
          setUiLockedState(false);
          updateEvaluateButtonState();
          if (currentAttempts >= MAX_ATTEMPTS) {
            evaluateBtn.disabled = true;
          }
        }
      });

      nextBtn.addEventListener("click", async () => {
        await sendTranscriptOnNext();
        const ctx = getStudentContext();
        const isLastQuestion = currentIndex + 1 >= questions.length;
        const nextQuestionValue = isLastQuestion ? "XXX" : String(currentIndex + 2);
        const payload = {
          FullName: ctx.fullName,
          ContactID: String(ctx.contactId),
          GivenName: ctx.givenName,
          CurrentQuestion: nextQuestionValue,
        };
        logAssessmentDebug("Next webhook", "Sending payload");
        const url =
          "https://default63871d3cd05d49fa86b6420054699f.b4.environment.api.powerplatform.com:443/powerautomate/automations/direct/workflows/5403405d1b2543a48ccd83c2d5f703ee/triggers/manual/paths/invoke?api-version=1&sp=%2Ftriggers%2Fmanual%2Frun&sv=1.0&sig=vNYYnuckqabWJ9uC_CH0kGTymUyBIutten9INl_-f-s";
        try {
          const response = await fetch(url, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          logDebugDetail("Next question HTTP status", `${response.status} ${response.statusText}`);
          logAssessmentDebug("Next webhook", `${response.status} ${response.statusText}`);
          const text = await response.text();
          if (text) {
            logDebugDetail("Next question response", text);
            logAssessmentDebug("Next response", text);
          }
          if (!response.ok) {
            throw new Error(`Next webhook failed (${response.status}) ${response.statusText}`.trim());
          }
        } catch (error) {
          logDebugDetail("Next question error", error?.message || String(error));
          logAssessmentDebug("Next error", error?.message || String(error));
          setStatus(error?.message || "Next webhook failed.");
          return;
        }
        if (isLastQuestion) {
          setStatus("All questions completed.");
          headerTitleEl.textContent = "Compliance - Completed";
          questionTextEl.textContent = "You have completed all questions.";
          answerInputEl.value = "";
          nextBtn.disabled = true;
          return;
        }
        currentIndex += 1;
        renderQuestion();
        setStatus("Ready.");
      });

      finalBtn?.addEventListener("click", async () => {
        try {
          const reviewText = buildFullTranscript();
          const prompt = buildFinalReviewPrompt(reviewText);
          setStatus("Generating final review...");
          finalBtn.disabled = true;
          const html = await callTextModel(prompt);
          const reportWindow = window.open("", "RPLFinalReview", "width=900,height=700,scrollbars=yes");
          if (!reportWindow) {
            setStatus("Popup blocked. Please allow pop-ups to view the report.");
            finalBtn.disabled = false;
            return;
          }
          reportWindow.document.open();
          reportWindow.document.write(html);
          reportWindow.document.close();
          setStatus("Final review ready.");
        } catch (err) {
          setStatus(err?.message || "Unable to generate final review.");
        } finally {
          finalBtn.disabled = false;
        }
      });

      transcriptBtn?.addEventListener("click", () => {
        const transcriptText = buildFullTranscript();
        const reportWindow = window.open("", "RPLTranscript", "width=900,height=700,scrollbars=yes");
        if (!reportWindow) {
          setStatus("Popup blocked. Please allow pop-ups to view the transcript.");
          return;
        }
        const escaped = transcriptText
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;");
        reportWindow.document.open();
        reportWindow.document.write(`<pre style="font-family:Segoe UI, Tahoma, Geneva, Verdana, sans-serif; white-space:pre-wrap;">${escaped}</pre>`);
        reportWindow.document.close();
      });

      responseBtn?.addEventListener("click", () => {
        const responseText = lastStudentContextResponseText;
        if (!responseText) {
          setStatus("Webhook response not available yet.");
          return;
        }
        const reportWindow = window.open("", "RPLResponse", "width=900,height=700,scrollbars=yes");
        if (!reportWindow) {
          setStatus("Popup blocked. Please allow pop-ups to view the response.");
          return;
        }
        const escaped = responseText
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;");
        reportWindow.document.open();
        reportWindow.document.write(`<pre style="font-family:Segoe UI, Tahoma, Geneva, Verdana, sans-serif; white-space:pre-wrap;">${escaped}</pre>`);
        reportWindow.document.close();
      });

      questionBtn?.addEventListener("click", () => {
        const responseText = lastQuestionResponseText;
        if (!responseText) {
          setStatus("Question response not available yet.");
          return;
        }
        const reportWindow = window.open("", "RPLQuestionResponse", "width=900,height=700,scrollbars=yes");
        if (!reportWindow) {
          setStatus("Popup blocked. Please allow pop-ups to view the response.");
          return;
        }
        const escaped = responseText
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;");
        reportWindow.document.open();
        reportWindow.document.write(`<pre style="font-family:Segoe UI, Tahoma, Geneva, Verdana, sans-serif; white-space:pre-wrap;">${escaped}</pre>`);
        reportWindow.document.close();
      });

      tableBtn?.addEventListener("click", () => {
        const html = buildQuestionsTableHtml(questions);
        const reportWindow = window.open("", "RPLQuestionTable", "width=1100,height=700,scrollbars=yes");
        if (!reportWindow) {
          setStatus("Popup blocked. Please allow pop-ups to view the table.");
          return;
        }
        reportWindow.document.open();
        reportWindow.document.write(html);
        reportWindow.document.close();
      });
    </script>
  </body>
</html>
