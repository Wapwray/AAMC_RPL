<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>RPL Test (Text)</title>
    <style>
      :root {
        color-scheme: light;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        --bg: #f4f6f9;
        --card: #ffffff;
        --text: #0f172a;
        --muted: #64748b;
        --border: #e2e8f0;
        --primary: #0b6ea9;
        --primary-dark: #095c8b;
      }
      * { box-sizing: border-box; }
      body { margin: 0; background: var(--bg); color: var(--text); }
      .page { padding: 24px; }
      .shell { max-width: 1100px; margin: 0 auto; display: grid; gap: 18px; }
      .header { display: flex; align-items: center; justify-content: space-between; gap: 12px; }
      .header h1 { margin: 0; font-size: 20px; font-weight: 700; }
      .header .status { font-size: 13px; color: var(--muted); }
      .card { background: var(--card); border: 1px solid var(--border); border-radius: 14px; padding: 18px; box-shadow: 0 10px 24px rgba(15, 23, 42, 0.08); }
      .studentContext { display: flex; flex-wrap: wrap; gap: 10px 16px; align-items: baseline; justify-content: space-between; }
      .studentContext__name { font-weight: 700; font-size: 15px; }
      .studentContext__meta { font-size: 13px; color: var(--muted); }
      .micSelectRow { margin-top: 12px; display: grid; gap: 6px; }
      .micSelectHint { font-size: 12px; color: var(--muted); }
      /* .modeToggleRow { display: flex; align-items: center; justify-content: space-between; gap: 12px; }
      .modeLabel { font-size: 12px; color: var(--muted); text-transform: uppercase; letter-spacing: 0.06em; }
      .toggleWrap { display: inline-flex; align-items: center; gap: 10px; }
      .toggleSwitch { position: relative; width: 52px; height: 28px; background: #dbe7f2; border-radius: 999px; cursor: pointer; border: 1px solid #c7d9e8; }
      .toggleSwitch input { position: absolute; opacity: 0; width: 0; height: 0; }
      .toggleKnob { position: absolute; top: 3px; left: 3px; width: 22px; height: 22px; background: #ffffff; border-radius: 50%; box-shadow: 0 2px 6px rgba(15, 23, 42, 0.2); transition: transform 0.2s ease; }
      .toggleSwitch input:checked + .toggleKnob { transform: translateX(24px); }
      .modeValue { font-weight: 600; font-size: 13px; color: var(--text); } */
      .formGrid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 12px; }
      label { font-size: 13px; color: var(--muted); }
      input, select, textarea { width: 100%; border: 1px solid var(--border); border-radius: 10px; padding: 10px 12px; font: inherit; background: #ffffff; }
      textarea { resize: vertical; min-height: 80px; }
      .questionBox { border: 1px solid var(--border); border-radius: 12px; padding: 12px; min-height: 64px; background: #ffffff; }
      .chatHistory { border: 1px solid var(--border); border-radius: 12px; padding: 12px; min-height: 140px; background: #ffffff; }
      .chatEntry { padding: 10px 12px; border-radius: 10px; margin-bottom: 10px; font-size: 14px; line-height: 1.45; }
      .chatEntry:last-child { margin-bottom: 0; }
      .chatEntry.user { background: #eef6ff; border: 1px solid #d7e7ff; }
      .chatEntry.ai { background: #f8fafc; border: 1px solid var(--border); }
      .actions { display: flex; gap: 10px; flex-wrap: wrap; justify-content: flex-end; }
      .dictationControls { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
      .dictationStatus { font-size: 12px; color: var(--muted); }
      .debugBox { border: 1px dashed var(--border); border-radius: 12px; padding: 12px; background: #ffffff; font-size: 12px; color: var(--muted); white-space: pre-wrap; min-height: 80px; }
      button { appearance: none; border: none; border-radius: 999px; padding: 10px 16px; font-size: 14px; font-weight: 600; background: var(--primary); color: #ffffff; cursor: pointer; transition: background 0.2s ease; }
      button.secondary { background: #ffffff; color: var(--primary); border: 1px solid #c7d9e8; }
      button:disabled { opacity: 0.55; cursor: not-allowed; }
      button:hover:not(:disabled) { background: var(--primary-dark); }
      button.secondary:hover:not(:disabled) { background: #eef6ff; }
      .hidden { display: none !important; }
    </style>
  </head>
  <body>
    <div class="page">
      <div class="shell">
        <div class="header">
          <div style="font-weight:700; text-decoration:underline;">AAMC RPL QUIZ</div>
          <h1 id="headerTitle">Compliance - Question 1 of 0 - Attempt 1</h1>
          <div class="status" id="status">Idle.</div>
        </div>

        <div class="card" id="studentContextCard">
          <!-- <div class="modeToggleRow" style="margin-bottom:10px;">
            <div class="modeLabel">Environment</div>
            <div class="toggleWrap">
              <span class="modeValue" id="modeLabel">RPL Base</span>
              <label class="toggleSwitch" aria-label="Toggle environment">
                <input id="modeToggle" type="checkbox" />
                <span class="toggleKnob"></span>
              </label>
            </div>
          </div> -->
          <div class="studentContext">
            <div class="studentContext__name" id="studentFullName">Full Name: Billy Broker</div>
            <div class="studentContext__meta" id="studentGivenName">Given Name: Billy</div>
            <div class="studentContext__meta" id="studentContactId">Contact ID: 123456</div>
          </div>
          <div class="micSelectRow">
            <label for="micSelect">Microphone</label>
            <select id="micSelect">
              <option value="">Detecting microphonesâ€¦</option>
            </select>
            <div class="micSelectHint" id="micStatus">Select the microphone to use for dictation.</div>
          </div>
        </div>

        <div id="setupCard" class="card">
          <h2 style="margin-top:0;">RPL Test Setup</h2>
          <div class="formGrid">
            <div>
              <label for="fullName">Full name</label>
              <input id="fullName" type="text" placeholder="Enter full name" />
            </div>
            <div>
              <label for="industry">Industry</label>
              <select id="industry">
                <option value="">Select industry</option>
                <option>Banking</option>
                <option>Lending</option>
                <option>Mortgage Broking</option>
                <option>Finance Broking</option>
              </select>
            </div>
            <div>
              <label for="jobTitle">Job title</label>
              <input id="jobTitle" type="text" placeholder="Enter job title" />
            </div>
          </div>
          <div class="actions" style="margin-top:16px;">
            <button id="beginBtn">Begin</button>
          </div>
        </div>

        <div id="quizCard" class="card hidden">
          <div style="display:flex; flex-direction:column; gap:14px;">
            <div>
              <div class="questionBox" id="questionText"></div>
            </div>
            <div>
              <strong>Feedback</strong>
              <div class="chatHistory" id="chatHistory"></div>
            </div>
            <div id="debugSection">
              <strong>Debug</strong>
              <div class="debugBox" id="debugLog"></div>
            </div>
            <div>
              <strong>Your answer</strong>
              <div class="dictationControls" style="margin:8px 0 6px;">
                <button id="dictateStartBtn" class="secondary">Start dictation</button>
                <button id="dictateStopBtn" class="secondary" disabled>Stop dictation</button>
                <span class="dictationStatus" id="dictationStatus">Dictation idle.</span>
              </div>
              <textarea id="answerInput" placeholder="Type your answer here..."></textarea>
            </div>
            <div class="actions">
              <button id="evaluateBtn">Evaluate</button>
              <button id="nextBtn" class="secondary" disabled>Next</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      const questionsUrl =
        "https://default4f0de57b35694b51b8c8b1dadd7ba8.19.environment.api.powerplatform.com:443/powerautomate/automations/direct/workflows/8feea7df352a455d9efde46977446910/triggers/manual/paths/invoke?api-version=1&sp=%2Ftriggers%2Fmanual%2Frun&sv=1.0&sig=AF-53thnNRJd9IxzY55POQzrW8owJ2SA6EhRycxtTEY";

      const statusEl = document.getElementById("status");
      const headerTitleEl = document.getElementById("headerTitle");
      const setupCard = document.getElementById("setupCard");
      const quizCard = document.getElementById("quizCard");
      const fullNameEl = document.getElementById("fullName");
      const industryEl = document.getElementById("industry");
      const jobTitleEl = document.getElementById("jobTitle");
      const beginBtn = document.getElementById("beginBtn");

      const questionTextEl = document.getElementById("questionText");
      const chatHistoryEl = document.getElementById("chatHistory");
      const debugSectionEl = document.getElementById("debugSection");
      const debugLogEl = document.getElementById("debugLog");
      const micSelectEl = document.getElementById("micSelect");
      const micStatusEl = document.getElementById("micStatus");
      const answerInputEl = document.getElementById("answerInput");
      const dictateStartBtn = document.getElementById("dictateStartBtn");
      const dictateStopBtn = document.getElementById("dictateStopBtn");
      const dictationStatusEl = document.getElementById("dictationStatus");
      const evaluateBtn = document.getElementById("evaluateBtn");
      const nextBtn = document.getElementById("nextBtn");
      // const modeToggleEl = document.getElementById("modeToggle");
      // const modeLabelEl = document.getElementById("modeLabel");

      let questions = [];
      let currentIndex = 0;
      let fullName = "";
      let firstName = "";
      let industry = "";
      let jobTitle = "";
      let recognition = null;
      let isDictating = false;
      let finalTranscript = "";
      let manualOverride = false;
      let aiMode = "router";
      const DEFAULT_FULL_NAME = "Billy Broker";
      const DEFAULT_GIVEN_NAME = "Billy";
      const DEFAULT_CONTACT_ID = "123456";
      const MIC_STORAGE_KEY = "rplMicDeviceId";

      const setStatus = (message) => {
        statusEl.textContent = message;
      };

      const isAdminDebugEnabled = () => window.location?.hash === "#admin";

      const updateDebugVisibility = () => {
        if (!debugSectionEl) return;
        debugSectionEl.classList.toggle("hidden", !isAdminDebugEnabled());
      };

      const pickFirstValue = (...candidates) => {
        for (const candidate of candidates) {
          if (candidate === undefined || candidate === null) continue;
          const text = typeof candidate === "string" ? candidate : String(candidate);
          if (text && text.trim()) return text.trim();
        }
        return "";
      };

      const setMicStatus = (message) => {
        if (micStatusEl) micStatusEl.textContent = message;
      };

      const populateMicrophones = async () => {
        if (!micSelectEl) return;
        if (!navigator?.mediaDevices?.enumerateDevices) {
          micSelectEl.innerHTML = "<option value=\"\">Microphone list not supported</option>";
          micSelectEl.disabled = true;
          setMicStatus("Microphone selection is not supported in this browser.");
          return;
        }

        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          stream.getTracks().forEach((track) => track.stop());
        } catch (err) {
          setMicStatus("Microphone access blocked. Allow access to list devices.");
        }

        try {
          const devices = await navigator.mediaDevices.enumerateDevices();
          const mics = devices.filter((device) => device.kind === "audioinput");
          const savedId = localStorage.getItem(MIC_STORAGE_KEY) || "";

          if (!mics.length) {
            micSelectEl.innerHTML = "<option value=\"\">No microphones found</option>";
            micSelectEl.disabled = true;
            setMicStatus("No microphone devices detected.");
            return;
          }

          micSelectEl.disabled = false;
          micSelectEl.innerHTML = "";
          mics.forEach((mic, index) => {
            const option = document.createElement("option");
            option.value = mic.deviceId;
            option.textContent = mic.label || `Microphone ${index + 1}`;
            micSelectEl.appendChild(option);
          });

          const selectedId = mics.some((mic) => mic.deviceId === savedId) ? savedId : mics[0].deviceId;
          micSelectEl.value = selectedId;
          localStorage.setItem(MIC_STORAGE_KEY, selectedId);
          setMicStatus("Microphone selection saved.");
        } catch (err) {
          micSelectEl.innerHTML = "<option value=\"\">Unable to load microphones</option>";
          micSelectEl.disabled = true;
          setMicStatus(err?.message || String(err));
        }
      };

      const applyUrlStudentContext = () => {
        if (typeof window.URLSearchParams !== "function") return {};
        try {
          const params = new URLSearchParams(window.location?.search || "");
          const fullName = params.get("fullName") ?? params.get("FullName") ?? params.get("studentName") ?? params.get("StudentName");
          const givenName = params.get("givenName") ?? params.get("GivenName");
          const contactId = params.get("contactId") ?? params.get("ContactID") ?? params.get("ContactId");

          const nextInfo = {
            ...(typeof window.RPLStudentInfo === "object" && window.RPLStudentInfo ? window.RPLStudentInfo : {}),
          };
          let mutated = false;

          if (fullName && fullName.trim()) {
            nextInfo.fullName = fullName.trim();
            nextInfo.studentName = fullName.trim();
            mutated = true;
          }
          if (givenName && givenName.trim()) {
            nextInfo.givenName = givenName.trim();
            mutated = true;
          }
          if (contactId && contactId.trim()) {
            nextInfo.contactId = contactId.trim();
            mutated = true;
          }

          if (mutated) {
            window.RPLStudentInfo = nextInfo;
            if (document.body?.dataset) {
              if (nextInfo.fullName || nextInfo.studentName) {
                document.body.dataset.fullName = nextInfo.fullName || nextInfo.studentName;
              }
              if (nextInfo.givenName) {
                document.body.dataset.givenName = nextInfo.givenName;
              }
              if (nextInfo.contactId) {
                document.body.dataset.contactId = nextInfo.contactId;
              }
            }
          }
          return nextInfo;
        } catch (err) {
          logDebug(`Unable to parse student URL params: ${err?.message || String(err)}`);
          return {};
        }
      };

      const getStudentContext = () => {
        const bodyDataset = document.body?.dataset || {};
        const studentInfo = window.RPLStudentInfo || window.rplStudentInfo || window.studentInfo || {};
        const fullName = pickFirstValue(
          studentInfo.fullName,
          studentInfo.studentName,
          bodyDataset.fullName,
          bodyDataset.studentName
        );
        const givenName = pickFirstValue(
          studentInfo.givenName,
          bodyDataset.givenName
        );
        const contactId = pickFirstValue(
          studentInfo.contactId,
          bodyDataset.contactId
        );
        return {
          fullName: fullName || DEFAULT_FULL_NAME,
          givenName: givenName || DEFAULT_GIVEN_NAME,
          contactId: contactId || DEFAULT_CONTACT_ID,
        };
      };

      const updateStudentContextBanner = () => {
        const fullNameEl = document.getElementById("studentFullName");
        const givenNameEl = document.getElementById("studentGivenName");
        const contactIdEl = document.getElementById("studentContactId");
        const ctx = getStudentContext();
        if (fullNameEl) fullNameEl.textContent = `Full Name: ${ctx.fullName}`;
        if (givenNameEl) givenNameEl.textContent = `Given Name: ${ctx.givenName}`;
        if (contactIdEl) contactIdEl.textContent = `Contact ID: ${ctx.contactId}`;
      };

      const sendStudentContextOnLoad = async () => {
        const ctx = getStudentContext();
        const payload = {
          FullName: ctx.fullName,
          ContactID: String(ctx.contactId),
          GivenName: ctx.givenName,
        };
        const url =
          "https://default63871d3cd05d49fa86b6420054699f.b4.environment.api.powerplatform.com:443/powerautomate/automations/direct/workflows/d39da5be329d41849dd8148dadc64016/triggers/manual/paths/invoke?api-version=1&sp=%2Ftriggers%2Fmanual%2Frun&sv=1.0&sig=cJzfjCDuTI3kVJNFpiiZT2S47B8zS5XvDwTBIQRX6XE";

        logDebug("Sending student context on load");
        logDebugDetail("Student context payload", payload);

        try {
          const response = await fetch(url, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          logDebugDetail("Student context HTTP status", `${response.status} ${response.statusText}`);
          const text = await response.text();
          logDebugDetail("Student context response", text || "(empty)");
        } catch (error) {
          logDebugDetail("Student context error", error?.message || String(error));
        }
      };

      // const updateModeLabel = () => {
      //   if (!modeLabelEl) return;
      //   modeLabelEl.textContent = aiMode === "router" ? "RPL Router" : "RPL Base";
      // };

      const logDebug = (message) => {
        if (!debugLogEl) return;
        const timestamp = new Date().toLocaleTimeString();
        debugLogEl.textContent = `[${timestamp}] ${message}\n` + debugLogEl.textContent;
      };

      const logDebugDetail = (label, detail) => {
        try {
          const formatted =
            typeof detail === "string"
              ? detail
              : JSON.stringify(detail, null, 2);
          logDebug(`${label}: ${formatted}`);
        } catch (err) {
          logDebug(`${label}: ${String(detail)}`);
        }
      };

      const updateDictationUi = (stateText) => {
        if (dictationStatusEl) {
          dictationStatusEl.textContent = stateText;
        }
        if (dictateStartBtn) dictateStartBtn.disabled = isDictating;
        if (dictateStopBtn) dictateStopBtn.disabled = !isDictating;
      };

      const ensureRecognition = () => {
        if (recognition) return recognition;
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRecognition) {
          updateDictationUi("Dictation not supported in this browser.");
          logDebug("SpeechRecognition API not available.");
          return null;
        }
        recognition = new SpeechRecognition();
        recognition.lang = "en-AU";
        recognition.continuous = true;
        recognition.interimResults = true;

        recognition.onstart = () => {
          isDictating = true;
          manualOverride = false;
          updateDictationUi("Listening...");
          logDebug("Dictation started.");
        };
        recognition.onend = () => {
          isDictating = false;
          updateDictationUi("Dictation stopped.");
          logDebug("Dictation stopped.");
        };
        recognition.onerror = (event) => {
          const message = event?.error ? `Dictation error: ${event.error}` : "Dictation error";
          updateDictationUi(message);
          logDebug(message);
        };
        recognition.onresult = (event) => {
          if (manualOverride) return;
          let interim = "";
          for (let i = event.resultIndex; i < event.results.length; i += 1) {
            const result = event.results[i];
            const text = result[0]?.transcript || "";
            if (result.isFinal) {
              finalTranscript += `${text} `;
            } else {
              interim += text;
            }
          }
          answerInputEl.value = `${finalTranscript}${interim}`.trim();
        };
        return recognition;
      };

      const startDictation = () => {
        const recog = ensureRecognition();
        if (!recog || isDictating) return;
        finalTranscript = answerInputEl.value.trim();
        if (finalTranscript) {
          finalTranscript = `${finalTranscript} `;
        }
        try {
          recog.start();
        } catch (err) {
          logDebug(`Dictation start failed: ${err?.message || String(err)}`);
        }
      };

      const stopDictation = () => {
        if (!recognition || !isDictating) return;
        try {
          recognition.stop();
        } catch (err) {
          logDebug(`Dictation stop failed: ${err?.message || String(err)}`);
        }
      };

      const parseListItems = (json) => {
        if (!json || typeof json.listitems !== "string") {
          return { items: [], error: "Response does not include listitems." };
        }
        try {
          const listItems = JSON.parse(json.listitems);
          if (!Array.isArray(listItems)) {
            return { items: [], error: "listitems is not an array." };
          }
          return { items: listItems, error: null };
        } catch (parseError) {
          return { items: [], error: parseError?.message || String(parseError) };
        }
      };

      const addChatEntry = (text, role) => {
        const entry = document.createElement("div");
        entry.className = `chatEntry ${role}`;
        entry.textContent = text;
        chatHistoryEl.appendChild(entry);
        chatHistoryEl.scrollTop = chatHistoryEl.scrollHeight;
      };

      const renderQuestion = () => {
        const question = questions[currentIndex] || {};
        const total = questions.length;
        const number = currentIndex + 1;
        headerTitleEl.textContent = `Compliance - Question ${number} of ${total} - Attempt 1`;
        questionTextEl.textContent = question.field_5 || question.Title || "";
        answerInputEl.value = "";
        nextBtn.disabled = true;
        chatHistoryEl.textContent = "";
      };

      const buildPrompt = (question, answer) => {
        const questionText = question.field_5 || question.Title || "";
        const objective = question.field_3 || "";
        return `You are an expert in the Australian Financial industry and are acting as an assessor of ${fullName}'s responses to the question '${questionText}'. ${firstName} gave the following first answer.\n\n${firstName} - ${answer}\n\nTake into account ${fullName} works in the ${industry} Industry as a ${jobTitle} and assess using the objective '${objective}' if they have demonstrated the required understanding, even if key terms, concepts, or regulations are implied rather than explicitly stated.\n\nProvide a concise overview to ${firstName} that follows these rules:\n\n1) If the response has effectively answered the question and meets the intent of the Objective, do not ask for any further details. Acknowledge that the response is sufficient and tell them to move to the next question.\n\n2) If the response has not effectively answered the question or does not meet the Objective, do not give the answer. Advise ${firstName} to add more details by pressing the 'Start' button or typing in the Chat box below. Tell them that if they cannot add any more they can move to the next question.\n\n3) Do not say 'Hi' at the start of the response.`;
      };

      const callTextModel = async (prompt) => {
        logDebug("Calling /api/analysis/chat");
        logDebugDetail("AI mode", aiMode);
        logDebugDetail("Prompt length", prompt?.length ?? 0);
        const response = await fetch("/api/analysis/chat", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "x-rpl-mode": aiMode,
          },
          body: JSON.stringify({
            prompt,
            temperature: 0.2,
            max_tokens: 300,
          }),
        });

        logDebugDetail("HTTP status", `${response.status} ${response.statusText}`);
        logDebugDetail("Response headers", Object.fromEntries(response.headers.entries()));

        if (!response.ok) {
          const text = await response.text();
          logDebug(`AI error ${response.status}: ${response.statusText} ${text}`);
          throw new Error(`Azure OpenAI error: ${response.status} ${response.statusText} ${text}`);
        }

        const json = await response.json();
        logDebug("AI response received.");
        logDebugDetail("AI response JSON", json);
        const content = json?.content || json?.response || json?.text;
        if (typeof content === "string" && content.trim()) return content.trim();
        const raw = json?.raw || {};
        logDebugDetail("AI response raw", raw);
        const rawContent =
          raw?.choices?.[0]?.message?.content ||
          raw?.choices?.[0]?.text ||
          raw?.content ||
          raw?.response ||
          raw?.text;
        if (typeof rawContent === "string" && rawContent.trim()) return rawContent.trim();
        const messages = Array.isArray(json?.messages) ? json.messages : [];
        const last = messages.length ? messages[messages.length - 1] : null;
        const text = last?.text || last?.content || "";
        if (!text) throw new Error("No response content returned.");
        return String(text).trim();
      };

      beginBtn.addEventListener("click", async () => {
        fullName = fullNameEl.value.trim();
        industry = industryEl.value.trim();
        jobTitle = jobTitleEl.value.trim();

        if (!fullName || !industry || !jobTitle) {
          setStatus("Please complete all fields.");
          return;
        }

        firstName = fullName.split(" ").filter(Boolean)[0] || fullName;
        setStatus("Loading questions...");
        beginBtn.disabled = true;

        try {
          const response = await fetch(questionsUrl, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
          });
          const json = await response.json();
          const { items, error } = parseListItems(json);
          if (error || !items.length) {
            throw new Error(error || "No questions returned.");
          }
          questions = items;
          currentIndex = 0;
          setupCard.classList.add("hidden");
          quizCard.classList.remove("hidden");
          renderQuestion();
          setStatus("Ready.");
        } catch (err) {
          setStatus(err?.message || String(err));
          beginBtn.disabled = false;
        }
      });

      applyUrlStudentContext();
      updateStudentContextBanner();
      // updateModeLabel();
      sendStudentContextOnLoad();
      updateDebugVisibility();
      populateMicrophones();

      dictateStartBtn?.addEventListener("click", () => startDictation());
      dictateStopBtn?.addEventListener("click", () => stopDictation());
      micSelectEl?.addEventListener("change", (event) => {
        const value = event.target?.value || "";
        localStorage.setItem(MIC_STORAGE_KEY, value);
        setMicStatus("Microphone selection saved.");
      });
      navigator?.mediaDevices?.addEventListener?.("devicechange", () => populateMicrophones());

      answerInputEl.addEventListener("input", () => {
        if (isDictating) {
          manualOverride = true;
          stopDictation();
        }
      });

      evaluateBtn.addEventListener("click", async () => {
        const answer = answerInputEl.value.trim();
        if (!answer) {
          setStatus("Please enter an answer before evaluating.");
          return;
        }

        addChatEntry(`Answer: ${answer}`, "user");
        setStatus("Evaluating response...");
        evaluateBtn.disabled = true;

        try {
          const prompt = buildPrompt(questions[currentIndex], answer);
          const feedback = await callTextModel(prompt);
          addChatEntry(feedback, "ai");
          nextBtn.disabled = false;
          setStatus("Feedback ready.");
        } catch (err) {
          addChatEntry(err?.message || String(err), "ai");
          setStatus("Evaluation failed.");
        } finally {
          evaluateBtn.disabled = false;
        }
      });

      nextBtn.addEventListener("click", () => {
        if (currentIndex + 1 >= questions.length) {
          setStatus("All questions completed.");
          headerTitleEl.textContent = "Compliance - Completed";
          questionTextEl.textContent = "You have completed all questions.";
          answerInputEl.value = "";
          nextBtn.disabled = true;
          return;
        }
        currentIndex += 1;
        renderQuestion();
        setStatus("Ready.");
      });
    </script>
  </body>
</html>
