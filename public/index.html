<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>RPL HOME</title>
    <style>
      <body>
        <div class="page">
          <div class="shell">
            <header>
              <div>
                <h1>Welcome to AAMC TRAINING RPL TESTING</h1>
                <div class="status">Launch the assessment when ready.</div>
              </div>
            </header>

            <section class="grid">
              <article class="card">
                <h2>RPL Assessment</h2>
                <div class="meta">Start the text-based RPL test experience.</div>
                <div class="controls">
                  <button id="rplTestTextBtn">Go to RPL Test (Text)</button>
                </div>
              </article>
            </section>
          </div>
        </div>

        <script>
          const rplTestTextBtn = document.getElementById("rplTestTextBtn");
          rplTestTextBtn.addEventListener("click", () => {
            window.location.href = "RPL_Test_Text.html";
          });
        </script>
      </body>
          return;
        }

        if (typeof data === "object") {
          const entries = Object.entries(data);
          if (!entries.length) {
            wrapEl.appendChild(createEmpty("Empty object returned."));
            return;
          }
          const table = document.createElement("table");
          const thead = document.createElement("thead");
          const headRow = document.createElement("tr");
          ["Field", "Value"].forEach((label) => {
            const th = document.createElement("th");
            th.textContent = label;
            headRow.appendChild(th);
          });
          thead.appendChild(headRow);
          table.appendChild(thead);
          const tbody = document.createElement("tbody");
          entries.forEach(([key, value]) => {
            const row = document.createElement("tr");
            const keyCell = document.createElement("td");
            keyCell.textContent = key;
            const valueCell = document.createElement("td");
            valueCell.textContent = value == null ? "" : String(value);
            row.appendChild(keyCell);
            row.appendChild(valueCell);
            tbody.appendChild(row);
          });
          table.appendChild(tbody);
          wrapEl.appendChild(table);
          return;
        }

        wrapEl.appendChild(createEmpty(String(data)));
      };

      const renderQuestionsList = (data, wrapEl) => {
        wrapEl.textContent = "";
        if (!data || typeof data.listitems !== "string") {
          wrapEl.appendChild(createEmpty("Response missing listitems string."));
          return;
        }
        try {
          const listItems = JSON.parse(data.listitems);
          if (!Array.isArray(listItems) || !listItems.length) {
            wrapEl.appendChild(createEmpty("listitems did not contain any rows."));
            return;
          }
          renderKeyValueTable(listItems, wrapEl);
        } catch (error) {
          renderKeyValueTable({ error: error?.message || String(error) }, wrapEl);
        }
      };

      const renderQuestionItem = (data, wrapEl) => {
        wrapEl.textContent = "";
        if (!data || typeof data !== "object") {
          wrapEl.appendChild(createEmpty("Response was not an object."));
          return;
        }
        const fields = {
          Title: data.Title ?? "",
          field_5: data.field_5 ?? "",
          field_3: data.field_3 ?? "",
          Hints: data.Hints ?? "",
        };
        renderKeyValueTable(fields, wrapEl);
      };

      const parseResponse = async (response) => {
        const contentType = response.headers.get("content-type") || "";
        if (contentType.includes("application/json")) {
          return response.json();
        }
        const text = await response.text();
        try {
          return JSON.parse(text);
        } catch {
          return { raw: text };
        }
      };

      const callWebhook = async ({ url, options }) => {
        const response = await fetch(url, options);
        const data = await parseResponse(response);
        return { ok: response.ok, status: response.status, data };
      };

      const loadQuestions = async () => {
        questionsBtn.disabled = true;
        setPill(questionsStatusEl, "Loading", null);
        setStatus("Fetching questions webhook...");
        try {
          const result = await callWebhook({
            url: questionsUrl,
            options: {
              method: "POST",
              headers: { "Content-Type": "application/json" },
            },
          });
          if (!result.ok) {
            setPill(questionsStatusEl, `Error ${result.status}`, "err");
          } else {
            setPill(questionsStatusEl, "OK", "ok");
          }
          renderQuestionItem(result.data, questionsTableWrap);
        } catch (error) {
          setPill(questionsStatusEl, "Failed", "err");
          renderKeyValueTable({ error: error?.message || String(error) }, questionsTableWrap);
        } finally {
          questionsBtn.disabled = false;
          setStatus("Ready.");
        }
      };

      const loadQuestions2 = async () => {
        questionsBtn2.disabled = true;
        setPill(questionsStatus2El, "Loading", null);
        setStatus("Fetching second webhook...");
        try {
          const result = await callWebhook({
            url: questionsUrl2,
            options: {
              method: "POST",
              headers: { "Content-Type": "application/json" },
            },
          });
          if (!result.ok) {
            setPill(questionsStatus2El, `Error ${result.status}`, "err");
          } else {
            setPill(questionsStatus2El, "OK", "ok");
          }
          renderQuestionsList(result.data, questionsTableWrap2);
        } catch (error) {
          setPill(questionsStatus2El, "Failed", "err");
          renderKeyValueTable({ error: error?.message || String(error) }, questionsTableWrap2);
        } finally {
          questionsBtn2.disabled = false;
          setStatus("Ready.");
        }
      };

      rplTestTextBtn.addEventListener("click", () => {
        window.location.href = "RPL_Test_Text.html";
      });
      questionsBtn.addEventListener("click", loadQuestions);
      questionsBtn2.addEventListener("click", loadQuestions2);
      refreshAllBtn.addEventListener("click", async () => {
        await loadQuestions();
        await loadQuestions2();
      });
    </script>
  </body>
</html>
